catalog_data:
  foo:
    coll:
      - {'_id': 1, 'bar': 11, 'car': 12}
      - {'_id': 2, 'bar': -11,'car': -12}
      - {'_id': 3, 'bar': 211,'car': 212}
    schema_coll:
      - {'_id': 1, 'bar': 11, 'car': 12}
      - {'_id': 2, 'bar': -11,'car': -12}
      - {'_id': 3, 'bar': 211,'car': 212}
    schema_foo:
      - {'_id': 1,'baz': 1}
    nested:
      - {'_id': 1,'n': {'a': 1}}
    bar:
      - {'_id': 1, 'a': 1}
      - {'_id': 2, 'a': 2}
    baz:
      - {'_id': 1, 'a': 1}
      - {'_id': 2, 'a': 3}

  foo2:
    coll:
      - {'_id': 1, 'a': 1, 'b': 2}

catalog_schema:
  {
    'foo': {
      'schema_coll': {
        'bsonType': "object",
        'required': [ 'bar', 'car' ],
        'additionalProperties': false,
        'properties': {
          'bar': {
            'bsonType': "int"
          },
          'car': {
            'bsonType': "int"
          }
        }
      },
      'schema_foo': {
        'bsonType': "object",
        'required': [ 'baz' ],
        'additionalProperties': false,
        'properties': {
          'baz': {
            'bsonType': "int"
          }
        }
      }
    }
  }

tests:
  - description: compound collection references are fully qualified
    current_db: 'foo'
    query: "SELECT * FROM foo.coll AS coll"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - { '$project': { '_id': 0, 'coll': '$$ROOT' } }
      - { '$project': { '_id': 0, 'coll': '$coll' } }
    result:
      - {'coll': {'_id': 1, 'bar': 11, 'car': 12}}
      - {'coll': {'_id': 2, 'bar': -11, 'car': -12}}
      - {'coll': {'_id': 3, 'bar': 211, 'car': 212}}

  - description: equivalent qualified and unqualified references to the same field
    current_db: 'foo'
    query: "SELECT VALUE {'ubar': bar, 'qbar': coll.bar} FROM foo.coll AS coll"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - {'$project': {'_id': 0, 'coll': '$$ROOT'}}
      - {'$project': {'_id': 0, 'coll': '$coll'}}
      - {'$project': {'_id': 0, '__bot': {'ubar': '$coll.bar', 'qbar': '$coll.bar'}}}
    result:
      - {'__bot': {'ubar': 11, 'qbar': 11}}
      - {'__bot': {'ubar': -11, 'qbar': -11}}
      - {'__bot': {'ubar': 211,'qbar': 211}}

  - description: compound field references prefer qualified names to field references
    current_db: 'foo'
    query: "SELECT VALUE {'a': n.a} FROM nested AS n"
    translation_target_db: foo
    translation_target_coll: nested
    translation:
      - { '$project': { '_id': 0, 'nested': '$$ROOT' } }
      - { '$project': { '_id': 0, 'n': '$nested' } }
      - { '$project': { '_id': 0, '__bot': { 'a': '$n.a'} } }
    result:
      - {'__bot': {}}

  - description: compound field reference is treated as unqualified if no datasource name matches first identifier
    current_db: 'foo'
    query: "SELECT VALUE {'a': n.a} FROM nested AS nested"
    translation_target_db: foo
    translation_target_coll: nested
    translation:
      - { '$project': { '_id': 0, 'nested': '$$ROOT' } }
      - { '$project': { '_id': 0, 'nested': '$nested' } }
      - { '$project': { '_id': 0, '__bot': { 'a': '$nested.n.a' } } }
    result:
      - {'__bot': {'a': 1}}

  - description: field references never resolve to the catalog environment
    current_db: 'foo'
    query: "SELECT VALUE {'a': foo.coll} FROM foo.coll AS coll"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - { '$project': { '_id': 0, 'coll': '$$ROOT' } }
      - { '$project': { '_id': 0, 'coll': '$coll' } }
      - { '$project': { '_id': 0, '__bot': { 'a': '$coll.foo.coll' } } }
    result:
      - {'__bot': {}}
      - {'__bot': {}}
      - {'__bot': {}}

  - description: unqualified references are ambiguous when there are multiple datasources without schemata
    current_db: 'foo'
    query: "SELECT VALUE {'a': bar} FROM foo.coll AS coll JOIN foo.coll AS coll2"
    should_compile: false
    algebrize_error: "Reference 'bar' is ambiguous"

  - description: qualified reference is not ambiguous with multiple datasources
    current_db: 'foo'
    query: "SELECT VALUE {'a': coll.bar} FROM foo.coll AS coll JOIN foo.nested AS nested"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - {'$project': {'_id': 0, 'coll': '$$ROOT'}}
      - {'$project': {'_id': 0, 'coll': '$coll'}}
      - {'$join': {
        'collection': 'nested',
        'joinType': 'inner',
        'pipeline': [
          {'$project': {'_id': 0, 'nested': '$$ROOT'}},
          {'$project': {'_id': 0, 'nested': '$nested'}},
        ],
      }}
      - {'$project': {'_id': 0, '__bot': {'a': '$coll.bar'}}}
    result:
      - {'__bot': {'a': 11}}
      - {'__bot': {'a': -11}}
      - {'__bot': {'a': 211}}

  - description: unqualified references are not ambiguous when there are multiple datasources with schema that disambiguates
    current_db: 'foo'
    query: "SELECT VALUE {'a': bar} FROM foo.schema_coll AS coll JOIN foo.schema_foo AS coll2"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - { '$project': { '_id': 0, 'schema_coll': '$$ROOT' } }
      - { '$project': { '_id': 0, 'coll': '$schema_coll' } }
      - { '$join': {
        'collection': 'schema_foo',
        'joinType': 'inner',
        'pipeline': [
          { '$project': { '_id': 0, 'schema_foo': '$$ROOT' } },
          { '$project': { '_id': 0, 'coll2': '$schema_foo' } },
        ],
      } }
      - { '$project': { '_id': 0, '__bot': { 'a': '$coll.bar' } } }
    result:
      - {'__bot': {'a': 11}}
      - {'__bot': {'a': -11}}
      - {'__bot': {'a': 211}}

  - description: unqualified collection reference refers to current database
    current_db: 'foo2'
    query: "SELECT * FROM coll AS coll"
    translation_target_db: foo2
    translation_target_coll: coll
    translation:
      - {'$project': {'_id': 0, 'coll': '$$ROOT'}}
      - {'$project': {'_id': 0, 'coll': '$coll'}}
    result:
      - {'coll': {'_id': 1, 'a': 1, 'b': 2}}

  - description: unqualified collection references do not resolve to collections in other databases
    current_db: 'foo2'
    query: "SELECT * FROM nested AS nested"
    skip_reason: "SQL-519: error when unqualified collection ref is not in current db"
    should_compile: false
    algebrize_error: "Unknown collection 'nested' in current database 'foo2'"

  - description: unqualified references are still ambiguous when there are multiple datasources with schema that have the same field names
    query: "SELECT VALUE {'a': bar} FROM foo.schema_coll AS coll JOIN foo.schema_coll AS coll2"
    should_compile: false
    algebrize_error: "Reference 'bar' is ambiguous"

  - description: unqualified collection reference will error if collection not found in current database
    current_db: 'foo'
    query: "SELECT * FROM car AS car"
    skip_reason: "SQL-519: error on invalid collection ref"
    should_compile: false
    algebrize_error: "Unknown collection 'car' in current database 'foo'"

  - description: qualified collection reference in FROM clause will error if collection not found in specified database
    current_db: 'foo'
    query: "SELECT * FROM foo.car AS car"
    skip_reason: "SQL-519: error on invalid collection ref"
    algebrize_error: "Unknown collection 'car' in database 'foo'"

  - description: qualified collection reference in FROM clause will error if database not found
    current_db: 'foo3'
    query: "SELECT * FROM bar AS bar"
    skip_reason: "SQL-519: error on invalid collection ref"
    algebrize_error: "Unknown database 'foo3'"

  - description: nonexistent field references fail with a schema
    query: "SELECT VALUE {'bar': foo.coll.bar} FROM foo.schema_coll AS coll"
    should_compile: false
    algebrize_error: "Unknown qualification or field 'foo'"

  - description: qualified collection reference in FROM clause will error if collection not found
    current_db: foo
    query: "SELECT * FROM bar.a AS a"
    skip_reason: "SQL-517: disallow field references in FROM clauses"
    should_compile: false
    algebrize_error: "Unknown collection a in database 'foo'"

  - description: a qualfied reference in a FROM clause can have no more than two parts
    current_db: 'foo'
    query: "SELECT * FROM foo.bar.bar AS bar"
    should_compile: false
    parse_error: "Collection references cannot have more than 2 parts, found 'foo.bar.bar' with 3 parts"

  - description: c.a refers to a in baz.a in the subquery and bar.a in the outer query
    current_db: 'foo'
    query: "SELECT * FROM bar AS c WHERE c.a IN (SELECT c.a FROM baz AS c)"
    skip_reason: "SQL-502, SQL-514"
    translation_target_db: foo
    translation_target_coll: bar
    translation:
      - {'$project': {'_id': 0, 'bar': '$$ROOT'}}
      - {'$project': {'_id': 0, 'c': '$bar'}}
      - {'$match': {'$expr': { '$subqueryComparison': {
        'op': 'eq',
        'modifier': 'all',
        'arg': '$c.a',
        'subquery': {
          'collection': 'target',
          'let': { 'bar_0': '$bar' },
          'outputPath': [ '__bot', 'a' ],
          'pipeline': [
            { '$project': { '_id': 0, 'baz': '$$ROOT' } },
            { '$project': { '_id': 0, 'c': '$baz' } },
            { '$project': { '_id': 0, '__bot': { 'a': '$c.a' } } }
          ]
        }
      } } } }
    result:
      - {'__bot': {'_id': 1, 'a': 1}}

  - description: with a qualified reference, the highest scope number for repeated qualifiers is chosen
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT q.bar FROM schema_foo AS q)} FROM schema_coll AS q"
    should_compile: false
    algebrize_error: "datasource 'q' does not contain field 'bar'"

  - description: if an unqualified reference CANNOT be from subquery's datasource and MUST be from outer query's datasource, use outer query's datasource
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM schema_foo AS q LIMIT 1)} FROM schema_coll AS q"
    skip_reason: "SQL-568: $lookup does not support `db` field"
    translation_target_db: foo
    translation_target_coll: schema_coll
    translation:
      - {'$project': {'_id': 0, 'schema_coll': '$$ROOT'}}
      - {'$project': {'_id': 0, 'q': '$schema_coll'}}
      - { '$project': { '_id': 0, '__bot': {
        'bar': { '$subquery': {
          'db': 'foo',
          'collection': 'schema_foo',
          'let': { 'q_0': '$q' },
          'outputPath': [ '__bot', 'bar' ],
          'pipeline': [
            { '$project': { '_id': 0, 'schema_foo': '$$ROOT' } },
            { '$project': { '_id': 0, 'q': '$schema_foo' } },
            { '$project': { '_id': 0, '__bot': { 'bar': '$$q_0.bar' } } },
            { '$limit': 1 }
          ]
        } }
      } } }
    result:
      - {'__bot': {'bar': 11}}
      - {'__bot': {'bar': -11}}
      - {'__bot': {'bar': 211}}

  - description: if an unqualified reference CANNOT be from subquery's datasource and MAY be from outer query's datasource, use outer query's datasource
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM schema_foo AS q LIMIT 1)} FROM coll AS q"
    skip_reason: "SQL-568: Fix $lookup desugaring"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - { '$project': { '_id': 0, 'coll': '$$ROOT' } }
      - { '$project': { '_id': 0, 'q': '$coll' } }
      - { '$project': { '_id': 0, '__bot': {
        'bar': { '$subquery': {
          'db': 'foo',
          'collection': 'schema_foo',
          'let': { 'q_0': '$q' },
          'outputPath': [ '__bot', 'bar' ],
          'pipeline': [
            { '$project': { '_id': 0, 'schema_foo': '$$ROOT' } },
            { '$project': { '_id': 0, 'q': '$schema_foo' } },
            { '$project': { '_id': 0, '__bot': { 'bar': '$$q.bar' } } },
            { '$limit': 1 }
          ]
        } }
      } } }
    result:
      - {'__bot': {'bar': 11}}
      - {'__bot': {'bar': -11}}
      - {'__bot': {'bar': 211}}

  - description: if an unqualified reference CANNOT be from subquery's datasource and CANNOT be from outer query's datasource, the datasource cannot be found
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT x FROM schema_coll AS q LIMIT 1)} FROM schema_foo AS q"
    should_compile: false
    algebrize_error: "reference 'x' does not exist in any in scope datasource: 'schema_coll', 'schema_foo'"

  - description: if an unqualified reference MAY be from subquery's datasource and MAY be from outer query's datasource, use outer query's datasource, the datasource is ambiguous
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM baz AS q LIMIT 1)} FROM coll AS q"
    should_compile: false
    algebrize_error: "ambiguous reference 'bar' MAY exist in datasource 'baz' or datasource 'coll'"

  - description: if an unqualified reference MAY be from subquery's datasource and MUST be from outer query's datasource, the datasource is ambiguous
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM baz AS q LIMIT 1)} FROM schema_coll AS q"
    should_compile: false
    algebrize_error: "ambiguous reference 'bar' MAY exist in datasource 'baz', but MUST exist in datasource 'schema_coll'"

  - description: if an unqualified reference MAY be from subquery's datasource and CANNOT be from outer query's datasource, use subquery's datasource
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM baz AS q LIMIT 1)} FROM schema_foo AS q"
    skip_reason: "SQL-568: Fix $lookup desugaring"
    translation_target_db: foo
    translation_target_coll: schema_foo
    translation:
      - { '$project': { '_id': 0, 'schema_foo': '$$ROOT' } }
      - { '$project': { '_id': 0, 'q': '$schema_foo' } }
      - { '$project': { '_id': 0, '__bot': {
        'bar': { '$subquery': {
          'db': 'foo',
          'collection': 'baz',
          'let': { 'q_0': '$q' },
          'outputPath': [ '__bot', 'bar' ],
          'pipeline': [
            { '$project': { '_id': 0, 'schema_foo': '$$ROOT' } },
            { '$project': { '_id': 0, 'q': '$baz' } },
            { '$project': { '_id': 0, '__bot': { 'bar': '$$q_0.bar' } } },
            { '$limit': 1 }
          ]
        } }
      } } }
    result:
      - {}
      - {}
      - {}

  - description: if an unqualified reference MUST be from subquery's datasource and MUST be from outer query's datasource, the highest scope number is chosen
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM schema_coll AS q LIMIT 1)} FROM schema_coll AS q"
    skip_reason: "SQL-568: $lookup does not support `db` field"
    translation_target_db: foo
    translation_target_coll: schema_coll
    translation:
      - { '$project': { '_id': 0, 'schema_coll': '$$ROOT' } }
      - { '$project': { '_id': 0, 'q': '$schema_coll' } }
      - { '$project': { '_id': 0, '__bot': {
        'bar': { '$subquery': {
          'db': 'foo',
          'collection': 'schema_coll',
          'let': { 'q_0': '$q' },
          'outputPath': [ '__bot', 'bar' ],
          'pipeline': [
            { '$project': { '_id': 0, 'schema_coll': '$$ROOT' } },
            { '$project': { '_id': 0, 'q': '$schema_coll' } },
            { '$project': { '_id': 0, '__bot': { 'bar': '$q.bar' } } },
            { '$limit': 1 }
          ]
        } }
      } } }
    result:
      - {'__bot': {'bar': 11}}

  - description: if an unqualified reference MUST be from subquery's datasource and MAY be from outer query's datasource, use subquery's datasource
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM schema_coll AS q LIMIT 1)} FROM coll AS q"
    skip_reason: "SQL-568: $lookup does not support `db` field"
    translation_target_db: foo
    translation_target_coll: coll
    translation:
      - { '$project': { '_id': 0, 'coll': '$$ROOT' } }
      - { '$project': { '_id': 0, 'q': '$coll' } }
      - { '$project': { '_id': 0, '__bot': {
        'bar': { '$subquery': {
          'db': 'foo',
          'collection': 'schema_coll',
          'let': { 'q_0': '$q' },
          'outputPath': [ '__bot', 'bar' ],
          'pipeline': [
            { '$project': { '_id': 0, 'schema_coll': '$$ROOT' } },
            { '$project': { '_id': 0, 'q': '$schema_coll' } },
            { '$project': { '_id': 0, '__bot': { 'bar': '$q.bar' } } },
            { '$limit': 1 }
          ]
        } }
      } } }
    result:
      - {'__bot': {'bar': 11}}


  - description: if an unqualified reference MUST be from subquery's datasource and CANNOT be from outer query's datasource, use subquery's datasource
    current_db: foo
    query: "SELECT VALUE{'bar': (SELECT bar FROM schema_coll AS q LIMIT 1)} FROM schema_foo AS q"
    skip_reason: "SQL-568: $lookup does not support `db` field"
    translation_target_db: foo
    translation_target_coll: schema_foo
    translation:
      - { '$project': { '_id': 0, 'schema_foo': '$$ROOT' } }
      - { '$project': { '_id': 0, 'q': '$schema_foo' } }
      - { '$project': { '_id': 0, '__bot': {
        'bar': { '$subquery': {
          'db': 'foo',
          'collection': 'schema_coll',
          'let': { 'q_0': '$q' },
          'outputPath': [ '__bot', 'bar' ],
          'pipeline': [
            { '$project': { '_id': 0, 'schema_coll': '$$ROOT' } },
            { '$project': { '_id': 0, 'q': '$schema_coll' } },
            { '$project': { '_id': 0, '__bot': { 'bar': '$q.bar' } } },
            { '$limit': 1 }
          ]
        } }
      } } }
    result:
      - {'__bot': {'bar': 11}}
