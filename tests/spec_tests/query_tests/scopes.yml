catalog_environment:
    {
        'foo': {
            'coll': [
                {
                  'bar': 11,
                  'car': 12
                },
                {
                  'bar': -11,
                  'car': -12
                },
                {
                  'bar': 211,
                  'car': 212
                }
            ],
            'schema_coll': [
                {
                  'bar': 11,
                  'car': 12
                },
                {
                  'bar': -11,
                  'car': -12
                },
                {
                  'bar': 211,
                  'car': 212
                }
            ],
            'schema_foo': [
                {'baz': 1}
            ],
            'nested': [
                {'n': {
                      'a': 1
                    }
                }
            ],
            'bar': [
                {'a': 1},
                {'a': 2}
            ],
            'baz': [
                {'a': 1},
                {'a': 3}
            ]
        },
        'foo2': {
             'coll': [
                {'a': 1, 'b': 2}
             ]

        }
    }

schema_environment:
  {
    'foo': {
      'schema_coll': {
        '$jsonSchema': {
          'bsonType': "object",
          'properties': {
            'bar': {
              'bsonType': "double"
            },
            'car': {
              'bsonType': "double"
            }
          }
        }
      },
      'schema_foo': {
        '$jsonSchema': {
          'bsonType': "object",
          'properties': {
            'baz': {
              'bsonType': "double"
            }
          }
        }
      }
    }
  }

tests:
  - description: compound collection references are fully qualified
    query: "SELECT * FROM foo.coll AS coll"
    result:
     - {
         'bar': 11,
         'car': 12
       }
     - {
         'bar': -11,
         'car': -12
       }
     - {
         'bar': 211,
         'car': 212
       }

  - description: equivalent qualified and unqualified references to the same field
    query: "SELECT VALUE {'ubar': bar, 'qbar': coll.bar} FROM foo.coll AS coll"
    result:
     - {
         'ubar': 11,
         'qbar': 11
       }
     - {
         'ubar': -11,
         'qbar': -11
       }
     - {
         'ubar': 211,
         'qbar': 211
       }

  - description: compound field references prefer qualified names to field references
    query: "SELECT VALUE {'a': n.a} FROM nested AS n"
    result:
     - {}

  - description: compound field reference is treated as unqualified if no datasource name matches first identifier
    query: "SELECT VALUE {'a': n.a} FROM nested AS nested"
    result:
     - {'a': 1}

  - description: field references never resolve to the catalog environment
    query: "SELECT VALUE {'a': foo.coll} FROM foo.coll AS coll"
    result:
     - {}
     - {}
     - {}

  - description: unqualified references are ambiguous when there are multiple datasources without schemata
    query: "SELECT VALUE {'a': bar} FROM foo.coll AS coll JOIN foo.coll AS coll2"
    error: "Reference 'bar' is ambiguous"

  - description: qualified reference is not ambiguous with multiple datasources
    query: "SELECT VALUE {'a': coll.bar} FROM foo.coll AS coll JOIN foo.nested AS nested"
    result:
     - {
         'a': 11
       }
     - {
         'a': -11
       }
     - {
         'a': 211
       }

  - description: unqualified references are not ambiguous when there are multiple datasources with schema that disambiguates
    query: "SELECT VALUE {'a': bar} FROM foo.schema_coll AS coll JOIN foo.schema_foo AS coll2"
    result:
     - {
         'a': 11
       }
     - {
         'a': -11
       }
     - {
         'a': 211
       }

  - description: unqualified collection reference refers to current database
    current_db: 'foo2'
    query: "SELECT * FROM coll AS coll"
    result:
     - {'a': 1, 'b': 2}

  - description: unqualified collection references do not resolve to collections in other databases
    current_db: 'foo2'
    query: "SELECT * FROM nested AS nested"
    error: "Unknown collection 'nested' in current database 'foo2'"

  - description: unqualified references are still ambiguous when there are multiple datasources with schema that have the same field names
    query: "SELECT VALUE {'a': bar} FROM foo.schema_coll AS coll JOIN foo.schema_coll AS coll2"
    error: "Reference 'bar' is ambiguous"

  - description: unqualified collection reference will error if collection not found in current database
    current_db: 'foo'
    query: "SELECT * FROM car AS car"
    error: "Unknown collection 'car' in current database 'foo'"

  - description: qualified collection reference in FROM clause will error if collection not found in specified database
    query: "SELECT * FROM foo.car AS car"
    error: "Unknown collection 'car' in database 'foo'"

  - description: qualified collection reference in FROM clause will error if database not found
    query: "SELECT * FROM test.car AS car"
    error: "Unknown database 'test'"

  - description: nonexistent field references fail with a schema
    query: "SELECT VALUE {'bar': foo.coll.bar} FROM foo.schema_coll AS coll"
    error: "Unknown qualfication or field 'foo'"

  - description: there are no field references in FROM clauses
    current_db: foo
    query: "SELECT * FROM foo.bar AS bar"
    error: "Unknown collection bar in datasource 'foo'"

  - description: a qualfied reference in a FROM clause can have no more than two parts
    query: "SELECT * FROM foo.bar.bar AS bar"
    error: "Collection references cannot have more than 2 parts, found 'foo.bar.bar' with 3 parts"

  - description: c.a refers to a in baz.a in the derived table and bar.a in the outer query
    query: "SELECT * FROM bar AS c WHERE c.a IN (SELECT c.a FROM baz AS c)"
    result:
     - {'a': 1}
