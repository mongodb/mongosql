catalog_data:
  foo:
    bar:
      - { _id: {"$numberInt": "1"}, v1: "abc"}
      - { _id: {"$numberInt": "2"}, v1: {"$numberInt": "2"}}
      - { _id: {"$numberInt": "3"}, v1: null}
    bar_schema:
      - { _id: {"$numberInt": "1"}, v1: "abc"}
      - { _id: {"$numberInt": "2"}, v1: {"$numberInt": "2"}}
      - { _id: {"$numberInt": "3"}, v1: null}

catalog_schema:
  {
    "foo": {
      "bar_schema": {
        "bsonType": "object",
        "required": [ '_id', 'v1' ],
        "additionalProperties": false,
        "properties": {
          "_id": {
            "bsonType": "int"
          },
          "v1": {
            "anyOf": [
              { "bsonType": "string" },
              { "bsonType": "int" },
              { "bsonType": !!str "null" }
            ]
          },
        }
      }
    }
  }

tests:
  - description: for expression with determined types, asserted type must be among those types
    current_db: "foo"
    query: "SELECT v1::!DOUBLE AS v1 FROM bar_schema"
    should_compile: false
    algebrize_error: "v1 cannot be asserted to DOUBLE type"

  - description: correctness test for type assertion in schema mode
    current_db: "foo"
    query: "SELECT v1::!INT AS v1 FROM bar_schema"
    skip_reason: "SQL-345: add a translation pipeline"
    translation_target_db: foo
    translation_target_coll: bar_schema
    result:
      - {v1: "abc"}
      - {v1: {"$numberInt": "2"}}
      - {v1: null}

  - description: correctness test for type assertion in schema-less mode, target type can be any
    current_db: "foo"
    query: "SELECT v1::!DOUBLE AS v1 FROM bar"
    skip_reason: "SQL-345: add a translation pipeline"
    translation_target_db: foo
    translation_target_coll: bar
    result:
      - {v1: "abc"}
      - {v1: {"$numberInt": "2"}}
      - {v1: null}
