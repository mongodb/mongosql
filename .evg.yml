stepback: true
command_type: system
buildvariants:
- name: debian71
  display_name: Debian 7.1
  run_on:
  - debian71-test
  expansions:
    cover: "-"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.mongodb.org/linux/mongodb-linux-x86_64-debian71-3.2.7.tgz
  tasks:
  - "!benchmark"
- name: debian81
  display_name: Debian 8.1
  run_on:
  - debian81-test
  expansions:
    cover: "-"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.mongodb.org/linux/mongodb-linux-x86_64-debian81-latest.tgz
  tasks:
  - "!benchmark"
- name: linux-64-amazon-ami
  display_name: Amazon Linux (Enterprise)
  expansions:
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-amzn64-3.2.7.tgz --output mongodb.tgz
    mongod_args: --sslMode requireSSL --sslPEMKeyFile ./testdata/server.pem
    mongo_args: --ssl --sslAllowInvalidCertificates --sslPEMKeyFile testdata/client.pem
    gotest_env: "SQLPROXY_SSLTEST=1"
  run_on:
    - linux-64-amzn-build
  tasks:
  - "*"
- name: osx
  display_name: OSX 10.10
  run_on:
  - osx-1010
  expansions:
    cover: "-"
    mongo_url: https://downloads.mongodb.org/osx/mongodb-osx-x86_64-3.2.7.tgz
  tasks:
  - "!benchmark"
- name: rhel55
  display_name: RHEL 5.5
  expansions:
    cover: "-"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-rhel57-3.2.7.tgz
  run_on:
  - rhel55
  tasks:
  - "!benchmark"
- name: rhel62
  display_name: RHEL 6.2
  expansions:
    cover: "-"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-rhel62-3.2.7.tgz
  run_on:
  - rhel62-test
  tasks:
  - "!benchmark"
- name: rhel70
  display_name: RHEL 7.0
  expansions:
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.7.tgz
  run_on:
  - rhel70
  tasks:
  - "!benchmark"
- name: rhel-71-ppc64le
  display_name: RHEL 7.1 PPC64LE
  expansions:
    cover: "-"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-ppc64le-enterprise-rhel71-3.2.7.tgz
  run_on:
  - rhel71-power8-test
  tasks:
  - "!benchmark"
- name: rhel-72-s390x
  display_name: RHEL 7.2 s390x
  expansions:
    cover: "-"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-s390x-enterprise-rhel72-latest.tgz
  run_on:
  - rhel72-zseries-build
  - rhel72-zseries-test
  tasks:
  - "!benchmark"
- name: solaris-64-bit
  display_name: Solaris
  expansions:
    cover: "-"
    gccgoflags: -gccgoflags "-lsocket -lnsl"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.mongodb.org/sunos5/mongodb-sunos5-x86_64-3.2.7.tgz
  run_on:
  - solaris
  tasks:
  - "!benchmark"
- name: suse11-64
  display_name: SLES 11
  expansions:
    cover: "-"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-suse11-3.2.7.tgz
  run_on:
  - suse11-test
  tasks:
  - "!benchmark"
- name: suse12-64
  display_name: SLES 12
  expansions:
    cover: "-"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-suse12-3.2.7.tgz
  run_on:
  - suse12-test
  tasks:
  - "!benchmark"
- name: ubuntu1404-64
  display_name: Ubuntu 14.04
  expansions:
    cover: "-"
    mongo_url: https://downloads.mongodb.org/linux/mongodb-linux-x86_64-3.2.7.tgz
  run_on:
  - ubuntu1404-build
  tasks:
  - "!benchmark"
- name: windows-32
  display_name: Windows 32
  run_on:
  - windows-32
  expansions:
    cover: "-"
    mongo_url: https://downloads.mongodb.org/win32/mongodb-win32-i386-3.2.7.zip
    extension: .exe
    # Set storage engine as mmapv1 for 32 bit variants
    # since WiredTiger requires 64 bit support.
    mongod_args: --storageEngine=mmapv1
  tasks:
  - "!benchmark"
- name: windows-64
  display_name: Windows 64
  run_on:
  - windows-64-vs2013-test
  expansions:
    cover: "-"
    mongo_url: https://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-3.2.7.zip
    extension: .exe
  tasks:
  - "!benchmark"
pre:
  - command: shell.track
  - command: shell.exec
    params:
      script: |
        rm -rf src
        mkdir src
  - command: shell.exec
    params:
      working_dir: src
      silent: true
      script: |
        echo "Building credential file..."
        cat > creds.yml <<END_OF_CREDS
        credentials:  {
          github: "${github_token}",
        }
        providers:
          aws:
            aws_id: "${aws_key}"
            aws_secret: "${aws_secret}"

        END_OF_CREDS
        echo "Done!"
  - command: shell.exec
    params:
      silent: true
      script: |
        ${killall_mci|pkill -9 mongo; pkill -9 mongodump; pkill -9 mongoexport; pkill -9 mongoimport; pkill -9 mongofiles; pkill -9 mongooplog; pkill -9 mongorestore; pkill -9 mongostat; pkill -9 mongotop; pkill -9 mongod; pkill -9 mongos; pkill -f buildlogger.py; pkill -f smoke.py} >/dev/null 2>&1
        rm -rf src /data/db/*
        exit 0
post:
  - command: gotest.parse_files
    params: 
      files: ["src/*.suite", "src/**/*.suite", "src/**/**/*.suite"]
  - command: shell.cleanup

functions:

  "build SQLProxy":
    command: shell.exec
    type: test
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        echo "Building SQLProxy"
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        # In RHEL 5.5, /usr/bin/ld can't handle --build-id parameters, so
        # use a wrapper if it's present on the system
        #
        if [ -d /opt/ldwrapper/bin ]
        then
          export PATH=/opt/ldwrapper/bin:$PATH
        fi
        . ./set_gopath.sh
        ${gorootvars} ${library_path} go build ${gccgoflags} -o sqlproxy main/main.go
        echo "Done!"

  "download mongod":
    command: shell.exec
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        rm -rf mongodb || true
        mkdir mongodb
        cd mongodb
        curl -s ${mongo_url} --output mongodb.tgz
        ${decompress} mongodb.tgz
        chmod +x ./mongodb-*/bin/*
        mv ./mongodb-*/bin/* .

  "download test data":
    command: shell.exec
    params:
      working_dir: src
      script: |
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/attendees.bson.gz --output testdata/input/attendees.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/flights201406.bson.gz --output testdata/input/flights201406.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Batters.bson.gz --output testdata/input/Batters.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Calcs.bson.gz --output testdata/input/Calcs.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/DateTime.bson.gz --output testdata/input/DateTime.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Election.bson.gz --output testdata/input/Election.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Fischeriris.bson.gz --output testdata/input/Fischeriris.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Loan.bson.gz --output testdata/input/Loan.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/NumericBins.bson.gz --output testdata/input/NumericBins.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Rei.bson.gz --output testdata/input/Rei.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/SeattleCrime.bson.gz --output testdata/input/SeattleCrime.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Securities.bson.gz --output testdata/input/Securities.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/SpecialData.bson.gz --output testdata/input/SpecialData.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Staples.bson.gz --output testdata/input/Staples.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/Starbucks.bson.gz --output testdata/input/Starbucks.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/UTStarcom.bson.gz --output testdata/input/UTStarcom.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/xy.bson.gz --output testdata/input/xy.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/bigarray.bson.gz --output testdata/input/bigarray.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/bigcoll.bson.gz --output testdata/input/bigcoll.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/bignestedarray.bson.gz --output testdata/input/bignestedarray.bson.gz
        curl -s http://s3.amazonaws.com/mciuploads/sqlproxy/data/bigobjarray.bson.gz --output testdata/input/bigobjarray.bson.gz

  "fetch source" :
    - command: git.get_project
      params:
        directory: src
    - command: git.apply_patch
      type: test
      params:
        directory: src

  "generate coverage txt":
    command: shell.exec
    params:
      working_dir: src
      script: |
        set -o verbose
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        . ./set_gopath.sh
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        perl -pe 's/.*src/github.com\/10gen\/sqlproxy/' coverage.out > coverage_rewrite.out
        if [ '${cover}' != '-' ]; then
          ${gorootvars} ${library_path} go tool cover ${gccgoflags} -func=coverage_rewrite.out -o coverage.txt
        fi;

  "generate coverage html":
    command: shell.exec
    params:
      working_dir: src
      script: |
        set -o verbose
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        . ./set_gopath.sh
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        perl -pe 's/.*src/github.com\/10gen\/sqlproxy/' coverage.out > coverage_rewrite.out
        if [ '${cover}' != '-' ]; then
          ${gorootvars} ${library_path} go tool cover ${gccgoflags} -html=coverage_rewrite.out -o coverage.html
        fi;

  "rewrite coverage report":
    command: shell.exec
    params:
      working_dir: src
      script: |
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        . ./set_gopath.sh
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        perl -pe 's/.*src/github.com\/10gen\/sqlproxy/' coverage.out > coverage_rewrite.out
        exit 0

  "setup creds":
    command: shell.exec
    params:
      script: |
        set -o verbose
        cp creds.yml src

  "start mongod":
    command: shell.exec
    params:
      working_dir: src
      background: true
      script: |
        set -o verbose
        rm -rf ../dbFiles && mkdir -p ../dbFiles;
        echo "Starting mongod...";
        ./mongodb/mongod${extension} ${mongod_args} --dbpath ../dbFiles --setParameter=enableTestCommands=1
        echo "Waiting for mongod to start up..."
        ./mongodb/mongo${extension} --nodb --eval 'assert.soon(function(x){try{var d = new Mongo("localhost:27017"); return true}catch(e){return false}}, "timed out connecting")' ${mongo_args}
        echo "Done!"

  "upload coverage html report":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/coverage.html
      remote_file: sqlproxy/coverage/${task_id}.html
      bucket: mciuploads
      permissions: public-read
      content_type: text/html
      display_name: Coverage Report (HTML)
      optional: true

  "upload benchmark report":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/benchmark.txt
      remote_file: sqlproxy/benchmarks/${build_variant}/${task_id}.txt
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: Benchmark Report (TXT)

  "upload coverage txt report":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/coverage.txt
      remote_file: sqlproxy/coverage/${task_id}.txt
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: Coverage Report (TXT)
      optional: true

  "upload SQLProxy":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/sqlproxy
      remote_file: sqlproxy/binaries/${task_id}/sqlproxy${extension}
      bucket: mciuploads
      permissions: public-read
      content_type: application/octet-stream
      display_name: sqlproxy${extension}

tasks:
- name: benchmark
  tags: ["benchmark"]
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          ${gorootvars} ${library_path} ${gotest_env} go run testdata/benchmark.go ${gccgoflags} -out benchmark_test.go
          ${gorootvars} ${library_path} ${gotest_env} go test -run benchmark_test.go ${gccgoflags} -bench=. -benchmem -benchtime=5s -v -timeout 4h > benchmark.txt 2>&1; if [ $? -ne 0 ]; then cat benchmark.txt; exit 1; else cat benchmark.txt; exit 0; fi
    - func: "upload benchmark report"

- name: blackbox
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          mkfifo test_pipe
          tee -a blackbox.suite < test_pipe&
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -blackbox -run TestBlackBox -timeout 4h -v ${cover|-coverprofile=coverage.out} > test_pipe;
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: blackbox-optoff
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          mkfifo test_pipe
          tee -a blackbox-optoff.suite < test_pipe&
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} SQLPROXY_OPTIMIZE_OFF=0 go test ${gccgoflags} -blackbox -run TestBlackBox -timeout 4h -v ${cover|-coverprofile=coverage.out} > test_pipe
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: dist
  commands:
    - func: "fetch source"
    - func: "build SQLProxy"
    - func: "upload SQLProxy"

- name: evaluator
  commands:
    - func: "fetch source"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          cd evaluator
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v ${cover|-coverprofile=coverage.out} > evaluator.suite 2>&1; if [ $? -ne 0 ]; then cat evaluator.suite; exit 1; else cat evaluator.suite; exit 0; fi
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          mv evaluator/coverage.out .
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: schema
  commands:
    - func: "fetch source"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          cd schema
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v ${cover|-coverprofile=coverage.out} > schema.suite 2>&1; if [ $? -ne 0 ]; then cat schema.suite; exit 1; else cat schema.suite; exit 0; fi
    - command: shell.exec
      params:
        working_dir: src
        script: |
          set -o verbose
          mv schema/coverage.out .
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: sqlproxy
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -timeout 4h -v ${cover|-coverprofile=coverage.out} > sqlproxy.suite 2>&1; if [ $? -ne 0 ]; then cat sqlproxy.suite; exit 1; else cat sqlproxy.suite; exit 0; fi
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: sqlproxy-optoff
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} SQLPROXY_OPTIMIZE_OFF=0 go test ${gccgoflags} -timeout 4h -v ${cover|-coverprofile=coverage.out} > sqlproxy-optoff.suite 2>&1; if [ $? -ne 0 ]; then cat sqlproxy-optoff.suite; exit 1; else cat sqlproxy-optoff.suite; exit 0; fi
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: tableau
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          . ./set_gopath.sh
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -tableau -run TestTableauDemo -timeout 4h -v ${cover|-coverprofile=coverage.out} > tableau.suite 2>&1; if [ $? -ne 0 ]; then cat tableau.suite; exit 1; else cat tableau.suite; exit 0; fi
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"
