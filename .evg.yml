stepback: true
command_type: system
buildvariants:
- name: debian71
  display_name: Debian 7.1
  run_on:
  - debian71-test
  expansions:
    build_tags: -tags "sasl ssl"
    cover: "-"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.mongodb.org/linux/mongodb-linux-x86_64-debian71-3.2.7.tgz
    push_arch: x86_64-debian71
    push_name: linux
    push_path: linux
  tasks:
  - "!benchmark !check"
- name: debian81
  display_name: Debian 8.1 (nightly)
  run_on:
  - debian81-test
  expansions:
    build_tags: -tags "sasl ssl"
    cover: "-"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.mongodb.org/linux/mongodb-linux-x86_64-debian81-latest.tgz
    push_arch: x86_64-debian81
    push_name: linux
    push_path: linux
  tasks:
  - "!benchmark !check"
- name: linux-64-amazon-ami
  display_name: Amazon Linux (Enterprise)
  expansions:
    build_tags: -tags "sasl ssl"
    gotest_env: "SQLPROXY_SSLTEST=1"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-amzn64-3.2.7.tgz --output mongodb.tgz
    mongod_args: --sslMode requireSSL --sslPEMKeyFile ./testdata/server.pem
    mongo_args: --ssl --sslAllowInvalidCertificates --sslPEMKeyFile testdata/client.pem
    push_arch: x86_64-enterprise-amzn64
    push_name: linux
    push_path: linux
  run_on:
    - linux-64-amzn-build
  tasks:
  - "!check"
- name: osx
  display_name: OSX 10.10
  run_on:
  - osx-1010
  expansions:
    build_tags: -tags "sasl ssl"
    cover: "-"
    mongo_url: https://downloads.mongodb.org/osx/mongodb-osx-x86_64-3.2.7.tgz
    push_arch: x86_64
    push_name: osx
    push_path: osx
  tasks:
  - "!benchmark !check"
- name: rhel55
  display_name: RHEL 5.5
  expansions:
    cover: "-"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-rhel57-3.2.7.tgz
    push_arch: x86_64-rhel55
    push_name: linux
    push_path: linux
  run_on:
  - rhel55
  tasks:
  - "!benchmark !check"
- name: rhel62
  display_name: RHEL 6.2
  expansions:
    build_tags: -tags "ssl"
    cover: "-"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-rhel62-3.2.7.tgz
    push_arch: x86_64-rhel62
    push_name: linux
    push_path: linux
  run_on:
  - rhel62-test
  tasks:
  - "!benchmark !check"
- name: rhel70
  display_name: RHEL 7.0
  expansions:
    build_tags: -tags "sasl ssl"
    gorootvars: GOROOT=/opt/go PATH="/opt/go/bin:$PATH"
    mongo_url: http://downloads.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.2.7.tgz
    push_arch: x86_64-rhel70
    push_name: linux
    push_path: linux
  run_on:
  - rhel70
  tasks:
  - "!benchmark !check"
- name: rhel-71-ppc64le
  display_name: RHEL 7.1 PPC64LE
  expansions:
    # RHEL 7.1 PPC64LE machines kerberos setup does not work
    build_tags: -gccgoflags "$(pkg-config --libs --cflags libssl)" -tags 'sasl ssl'
    cover: "-"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-ppc64le-enterprise-rhel71-3.2.7.tgz
    push_arch: ppc64le-rhel71
    push_name: linux
    push_path: linux
  run_on:
  - rhel71-power8-test
  tasks:
  - "!benchmark !check"
- name: rhel-72-s390x
  display_name: RHEL 7.2 s390x (nightly)
  expansions:
    build_tags: -gccgoflags "$(pkg-config --libs --cflags libssl)" -tags 'sasl ssl'
    cover: "-"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-s390x-enterprise-rhel72-latest.tgz
    push_arch: s390x-enterprise-rhel72
    push_name: linux
    push_path: linux
  run_on:
  - rhel72-zseries-build
  - rhel72-zseries-test
  tasks:
  - "!benchmark !check"
- name: solaris-64-bit
  display_name: Solaris
  expansions:
    cover: "-"
    gotest_env: "GOARCH=amd64 GOOS=solaris"
    gccgoflags: -gccgoflags "-lsocket -lnsl"
    library_path: PATH="/opt/mongodbtoolchain/v2/bin/:$PATH"
    mongo_url: http://downloads.mongodb.org/sunos5/mongodb-sunos5-x86_64-3.2.7.tgz
    push_arch: x86_64
    push_name: sunos5
    push_path: sunos5
  run_on:
  - solaris
  tasks:
  - "!benchmark !check"
- name: suse11-64
  display_name: SLES 11
  expansions:
    build_tags: -tags "sasl ssl"
    cover: "-"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-suse11-3.2.7.tgz
    push_arch: x86_64-suse11
    push_name: linux
    push_path: linux
  run_on:
  - suse11-test
  tasks:
  - "!benchmark !check"
- name: suse12-64
  display_name: SLES 12
  expansions:
    build_tags: -tags "sasl ssl"
    cover: "-"
    mongo_url: http://downloads.10gen.com/linux/mongodb-linux-x86_64-enterprise-suse12-3.2.7.tgz
    push_arch: x86_64-suse12
    push_name: linux
    push_path: linux
  run_on:
  - suse12-test
  tasks:
  - "!benchmark !check"
- name: ubuntu1404-64
  display_name: Ubuntu 14.04
  expansions:
    build_tags: -tags "sasl ssl"
    cover: "-"
    mongo_url: https://downloads.mongodb.org/linux/mongodb-linux-x86_64-3.2.7.tgz
    push_arch: x86_64-ubuntu1404
    push_name: linux
    push_path: linux
  run_on:
  - ubuntu1404-build
  tasks:
  - "!benchmark"
- name: windows-32
  display_name: Windows 32
  run_on:
  - windows-32
  expansions:
    archive_format: zip
    cover: "-"
    extension: .exe
    library_path: PATH="/cygdrive/c/mingw-w64/x86_64-4.9.1-posix-seh-rt_v3-rev1/mingw64/bin:/cygdrive/c/sasl/:$PATH"
    mongo_url: https://downloads.mongodb.org/win32/mongodb-win32-i386-3.2.7.zip
    # Set storage engine as mmapv1 for 32 bit variants
    # since WiredTiger requires 64 bit support.
    mongod_args: --storageEngine=mmapv1
    push_arch: i386
    push_name: win32
    push_path: win32
    separator: \\
  tasks:
  - "!benchmark !check"
- name: windows-64
  display_name: Windows 64
  run_on:
  - windows-64-vs2013-test
  expansions:
    archive_format: zip
    build_tags: -tags "sasl ssl"
    cover: "-"
    extension: .exe
    library_path: PATH="/cygdrive/c/mingw-w64/x86_64-4.9.1-posix-seh-rt_v3-rev1/mingw64/bin:/cygdrive/c/sasl/:$PATH"
    mongo_url: https://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-3.2.7.zip
    push_arch: x86_64
    push_name: win32
    push_path: win32
    separator: \\
  tasks:
  - "!benchmark !check"
pre:
  - command: shell.track
  - command: shell.exec
    params:
      script: |
        rm -rf src
        mkdir src
  - command: shell.exec
    params:
      working_dir: src
      silent: true
      script: |
        echo "Building credential file..."
        cat > creds.yml <<END_OF_CREDS
        credentials:  {
          github: "${github_token}",
        }
        providers:
          aws:
            aws_id: "${aws_key}"
            aws_secret: "${aws_secret}"

        END_OF_CREDS
        echo "Done!"
  - command: shell.exec
    params:
      silent: true
      script: |
        ${killall_mci|pkill -9 mongo; pkill -9 mongodump; pkill -9 mongoexport; pkill -9 mongoimport; pkill -9 mongofiles; pkill -9 mongooplog; pkill -9 mongorestore; pkill -9 mongostat; pkill -9 mongotop; pkill -9 mongod; pkill -9 mongos; pkill -f buildlogger.py; pkill -f smoke.py} >/dev/null 2>&1
        rm -rf src /data/db/*
        exit 0
post:
  - command: gotest.parse_files
    params:
      files: ["src/*.suite", "src/**/*.suite", "src/**/**/*.suite"]
  - command: shell.cleanup

functions:

  "check formatting":
    command: shell.exec
    type: test
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        echo "Checking formatting"
        unformatted=$(${gorootvars} ${library_path} gofmt -e -l `find . -path ./vendor -prune -o -name '*.go' -print` 2>&1)

        for fn in $unformatted; do
          echo >&2 "  Unformatted: $fn"
        done
        [ -z "$unformatted" ] || exit 1

        echo "Done!"

  "build MongoDRDL":
    command: shell.exec
    type: test
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        echo "Building MongoDRDL"
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        # In RHEL 5.5, /usr/bin/ld can't handle --build-id parameters, so
        # use a wrapper if it's present on the system
        #
        if [ -d /opt/ldwrapper/bin ]
        then
          export PATH=/opt/ldwrapper/bin:$PATH
        fi
        . ./set_gopath.sh
        ${gorootvars} ${library_path} go build -ldflags "-X github.com/10gen/sqlproxy/common.Gitspec=$(git rev-parse HEAD) -X github.com/10gen/sqlproxy/common.VersionStr=$(git describe)" ${gccgoflags} ${build_tags} -o drdl mongodrdl/main/mongodrdl.go

        echo "Done!"

  "build SQLProxy":
    command: shell.exec
    type: test
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        echo "Building SQLProxy"
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        # In RHEL 5.5, /usr/bin/ld can't handle --build-id parameters, so
        # use a wrapper if it's present on the system
        #
        if [ -d /opt/ldwrapper/bin ]
        then
          export PATH=/opt/ldwrapper/bin:$PATH
        fi
        . ./set_gopath.sh
        ${gorootvars} ${library_path} go build -ldflags "-X github.com/10gen/sqlproxy/common.Gitspec=$(git rev-parse HEAD) -X github.com/10gen/sqlproxy/common.VersionStr=$(git describe)" ${gccgoflags} -o sqlproxy main/sqlproxy.go
        echo "Done!"

  "create release":
    command: shell.exec
    type: test
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        rm -rf build
        mkdir build
        cp drdl sqlproxy build
        ${python|python} buildscripts/make_archive.py -o release.${archive_format|tgz} --format ${archive_format|tgz} --transform build/sqlproxy=bin/sqlproxy${extension} --transform build/drdl=bin/mongodrdl${extension} --transform distsrc/README=README --transform distsrc/THIRD-PARTY-NOTICES=THIRD-PARTY-NOTICES LICENSE distsrc${separator|/}README distsrc${separator|/}THIRD-PARTY-NOTICES build${separator|/}sqlproxy build${separator|/}drdl
        echo version: $(git --git-dir .git describe) > version.yml

  "download mongod":
    command: shell.exec
    params:
      working_dir: src
      script: |
        set -o verbose
        set -o errexit
        rm -rf mongodb || true
        mkdir mongodb
        cd mongodb
        curl -s ${mongo_url} --output mongodb.tgz
        ${decompress} mongodb.tgz
        chmod +x ./mongodb-*/bin/*
        mv ./mongodb-*/bin/* .

  "download test data":
    command: shell.exec
    params:
      working_dir: src
      script: |
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/attendees.bson.gz --output testdata/input/attendees.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/flights201406.bson.gz --output testdata/input/flights201406.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Batters.bson.gz --output testdata/input/Batters.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Calcs.bson.gz --output testdata/input/Calcs.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/DateTime.bson.gz --output testdata/input/DateTime.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Election.bson.gz --output testdata/input/Election.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Fischeriris.bson.gz --output testdata/input/Fischeriris.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Loan.bson.gz --output testdata/input/Loan.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/NumericBins.bson.gz --output testdata/input/NumericBins.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Rei.bson.gz --output testdata/input/Rei.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/SeattleCrime.bson.gz --output testdata/input/SeattleCrime.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Securities.bson.gz --output testdata/input/Securities.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/SpecialData.bson.gz --output testdata/input/SpecialData.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Staples.bson.gz --output testdata/input/Staples.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/Starbucks.bson.gz --output testdata/input/Starbucks.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/UTStarcom.bson.gz --output testdata/input/UTStarcom.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/xy.bson.gz --output testdata/input/xy.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/bigarray.bson.gz --output testdata/input/bigarray.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/bigcoll.bson.gz --output testdata/input/bigcoll.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/bignestedarray.bson.gz --output testdata/input/bignestedarray.bson.gz
        curl -s http://s3.amazonaws.com/noexpire/sqlproxy/data/bigobjarray.bson.gz --output testdata/input/bigobjarray.bson.gz

  "fetch source" :
    - command: git.get_project
      params:
        directory: src
    - command: git.apply_patch
      type: test
      params:
        directory: src

  "generate coverage txt":
    command: shell.exec
    params:
      working_dir: src
      script: |
        set -o verbose
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        . ./set_gopath.sh
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        perl -pe 's/.*src/github.com\/10gen\/sqlproxy/' coverage.out > coverage_rewrite.out
        if [ '${cover}' != '-' ]; then
          ${gorootvars} ${library_path} go tool cover ${gccgoflags} -func=coverage_rewrite.out -o coverage.txt
        fi;

  "generate coverage html":
    command: shell.exec
    params:
      working_dir: src
      script: |
        set -o verbose
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        . ./set_gopath.sh
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        perl -pe 's/.*src/github.com\/10gen\/sqlproxy/' coverage.out > coverage_rewrite.out
        if [ '${cover}' != '-' ]; then
          ${gorootvars} ${library_path} go tool cover ${gccgoflags} -html=coverage_rewrite.out -o coverage.html
        fi;

  "rewrite coverage report":
    command: shell.exec
    params:
      working_dir: src
      script: |
        if [ "Windows_NT" = "$OS" ]; then
          set -o igncr
        fi;
        . ./set_gopath.sh
        if [ '${library_path}' != '' ]; then
          export ${library_path}
        fi;
        perl -pe 's/.*src/github.com\/10gen\/sqlproxy/' coverage.out > coverage_rewrite.out
        exit 0

  "setup creds":
    command: shell.exec
    params:
      script: |
        set -o verbose
        cp creds.yml src

  "start mongod":
    command: shell.exec
    params:
      working_dir: src
      background: true
      script: |
        set -o verbose
        rm -rf ../dbFiles && mkdir -p ../dbFiles;
        echo "Starting mongod...";
        ./mongodb/mongod${extension} ${mongod_args} --dbpath ../dbFiles --setParameter=enableTestCommands=1
        echo "Waiting for mongod to start up..."
        ./mongodb/mongo${extension} --nodb --eval 'assert.soon(function(x){try{var d = new Mongo("localhost:27017"); return true}catch(e){return false}}, "timed out connecting")' ${mongo_args}
        echo "Done!"

  "upload coverage html report":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/coverage.html
      remote_file: sqlproxy/coverage/${task_id}.html
      bucket: mciuploads
      permissions: public-read
      content_type: text/html
      display_name: Coverage Report (HTML)
      optional: true

  "upload benchmark report":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/benchmark.txt
      remote_file: sqlproxy/benchmarks/${build_variant}/${task_id}.txt
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: Benchmark Report (TXT)

  "upload coverage txt report":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/coverage.txt
      remote_file: sqlproxy/coverage/${task_id}.txt
      bucket: mciuploads
      permissions: public-read
      content_type: text/plain
      display_name: Coverage Report (TXT)
      optional: true

  "upload release":
    command: s3.put
    params:
      aws_key: ${aws_key}
      aws_secret: ${aws_secret}
      local_file: src/release.${archive_format|tgz}
      remote_file: sqlproxy/binaries/${push_path}/mongodb-bi-${push_name}-${push_arch}-${version}.${archive_format|tgz}
      bucket: mciuploads
      permissions: public-read
      content_type: application/octet-stream
      display_name: mongodb-bi-${push_name}-${push_arch}-${version}.${archive_format|tgz}

tasks:
- name: benchmark
  tags: ["benchmark"]
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          ${gorootvars} ${library_path} ${gotest_env} go run testdata/benchmark.go ${gccgoflags} -out benchmark_test.go
          ${gorootvars} ${library_path} ${gotest_env} go test -run benchmark_test.go ${gccgoflags} -bench=. -benchmem -benchtime=5s -v -timeout 4h > benchmark.txt 2>&1; if [ $? -ne 0 ]; then cat benchmark.txt; exit 1; else cat benchmark.txt; exit 0; fi
    - func: "upload benchmark report"

- name: blackbox
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          mkfifo test_pipe
          tee -a blackbox.suite < test_pipe&
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go run testdata/blackbox.go ${gccgoflags} -out blackbox_test.go
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -run TestBlackBox -parallel 10 -timeout 4h -v ${cover|-coverprofile=coverage.out} > test_pipe;
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: blackbox-optoff
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          mkfifo test_pipe
          tee -a blackbox-optoff.suite < test_pipe&
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go run testdata/blackbox.go ${gccgoflags} -out blackbox_test.go
          ${gorootvars} ${library_path} ${gotest_env} SQLPROXY_OPTIMIZE_OFF=0 go test ${gccgoflags} -run TestBlackBox -parallel 10 -timeout 4h -v ${cover|-coverprofile=coverage.out} > test_pipe
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: check
  tags: ["check"]
  commands:
    - func: "fetch source"
    - func: "check formatting"

- name: dist
  commands:
    - func: "fetch source"
    - func: "build SQLProxy"
    - func: "build MongoDRDL"
    - func: "create release"
    - command: expansions.update
      params:
        file: src/version.yml
    - func: "upload release"

- name: evaluator
  commands:
    - func: "fetch source"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          cd evaluator
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v ${cover|-coverprofile=coverage.out} > evaluator.suite 2>&1; if [ $? -ne 0 ]; then cat evaluator.suite; exit 1; else cat evaluator.suite; exit 0; fi
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          mv evaluator/coverage.out .
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: mongodrdl
  commands:
    - func: "fetch source"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          cd mongodrdl
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v > mongodrdl.suite 2>&1; if [ $? -ne 0 ]; then cat mongodrdl.suite; exit 1; else cat mongodrdl.suite; fi
          cd mongo
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v > mongo.suite 2>&1; if [ $? -ne 0 ]; then cat mongo.suite; exit 1; else cat mongo.suite; fi
          cd ../relational
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v > relational.suite 2>&1; if [ $? -ne 0 ]; then cat relational.suite; exit 1; else cat relational.suite; fi
          exit 0
- name: schema
  commands:
    - func: "fetch source"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          cd schema
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -v ${cover|-coverprofile=coverage.out} > schema.suite 2>&1; if [ $? -ne 0 ]; then cat schema.suite; exit 1; else cat schema.suite; exit 0; fi
    - command: shell.exec
      params:
        working_dir: src
        script: |
          set -o verbose
          mv schema/coverage.out .
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: sqlproxy
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -timeout 4h -v ${cover|-coverprofile=coverage.out} > sqlproxy.suite 2>&1; if [ $? -ne 0 ]; then cat sqlproxy.suite; exit 1; else cat sqlproxy.suite; exit 0; fi
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: sqlproxy-optoff
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          . ./set_gopath.sh
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} SQLPROXY_OPTIMIZE_OFF=0 go test ${gccgoflags} -timeout 4h -v ${cover|-coverprofile=coverage.out} > sqlproxy-optoff.suite 2>&1; if [ $? -ne 0 ]; then cat sqlproxy-optoff.suite; exit 1; else cat sqlproxy-optoff.suite; exit 0; fi
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"

- name: tableau
  commands:
    - func: "fetch source"
    - func: "download test data"
    - func: "download mongod"
    - func: "start mongod"
    - command: shell.exec
      type: test
      params:
        working_dir: src
        script: |
          set -o verbose
          set -o errexit
          if [ "Windows_NT" = "$OS" ]; then
            set -o igncr
          fi;
          . ./set_gopath.sh
          if [ '${library_path}' != '' ]; then
            export ${library_path}
          fi;
          touch coverage.out
          ${gorootvars} ${library_path} ${gotest_env} go test ${gccgoflags} -tableau -run TestTableauDemo -timeout 4h -v ${cover|-coverprofile=coverage.out} > tableau.suite 2>&1; if [ $? -ne 0 ]; then cat tableau.suite; exit 1; else cat tableau.suite; exit 0; fi
    - func: "rewrite coverage report"
    - func: "generate coverage html"
    - func: "generate coverage txt"
    - func: "upload coverage html report"
    - func: "upload coverage txt report"
