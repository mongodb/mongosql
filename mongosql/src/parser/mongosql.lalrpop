use crate::parser::ast::*;
use crate::parser::util::*;
use lalrpop_util::ParseError;
use std::str::FromStr;
use std::convert::TryFrom;

grammar;

extern {
    type Error = String;
}

pub Query: Query = {
  SetQuery => Query::Set(<>),
  SelectQuery => Query::Select(<>),
};

SetQuery: SetQuery = {
  <q:Query> <o:SetOperator> <s:SelectQuery>  => SetQuery{left:Box::new(q), op:o, right:Box::new(Query::Select(s))},
}

SelectQuery: SelectQuery = {
    <s:SelectClause>
    <f:FromClause?>
    <w:WhereClause?>
    <o:OrderByClause?>
    <lo:LimitOffset?> =>
        SelectQuery{
            select_clause: s,
            from_clause: f,
            where_clause: w,
            order_by_clause: o,
            limit: lo.unwrap_or((None,None)).0,
            offset: lo.unwrap_or((None,None)).1
        }
};

SelectClause: SelectClause = {
  SELECT <q:SetQuantifier?> <b:SelectBody> => SelectClause{set_quantifier:q.unwrap_or(SetQuantifier::All), body:b},
}

FromClause: Datasource = {
    FROM <Datasource>,
}

SimpleDatasource: Datasource = {
    <ae: AliasedExpr> =>? parse_simple_datasource(ae)
}

JoinDatasource: Datasource = {
    <d:Datasource> COMMA <sd:SimpleDatasource> => {
        Datasource::Join(
            JoinSource {
                join_type: JoinType::Cross,
                left: Box::new(d),
                right: Box::new(sd),
                condition: None,
            }
        )
    },
    <d:Datasource> <jt:JoinType> JOIN <sd:SimpleDatasource> <c:(ON <Expression>)?> => {
        Datasource::Join(
            JoinSource {
                join_type: jt,
                left: Box::new(d),
                right: Box::new(sd),
                condition: c,
            }
        )
    },
}

Datasource: Datasource = {
    <SimpleDatasource>,
    <JoinDatasource>,
}

JoinType: JoinType = {
    LEFT OUTER? => JoinType::Left,
    RIGHT OUTER? => JoinType::Right,
    INNER => JoinType::Inner,
    CROSS? => JoinType::Cross,
}

WhereClause: Expression = {
  WHERE <Expression>,
}

OrderByClause: OrderByClause = {
  ORDER BY <s:Comma<SortSpec>> => OrderByClause{sort_specs:s},
}

SortSpec: SortSpec = {
  <k:SortKey> <d:SortDirection?> => SortSpec{key:k, direction:d.unwrap_or(SortDirection::Asc)},
}

SortKey: SortKey = {
  Identifier => SortKey::Simple(<>),
  Unsigned32 => SortKey::Positional(<>),
}

SortDirection: SortDirection = {
  ASC => SortDirection::Asc,
  DESC => SortDirection::Desc,
}

LimitOffset: (Option<u32>, Option<u32>) = {
  <l:Limit> <o:Offset?> => (Some(l), o),
  <o:Offset> <l:Limit?> => (l, Some(o)),
  LIMIT <l:Unsigned32> COMMA <o:Unsigned32> => (Some(l), Some(o)),
};

Limit: u32 = {
  LIMIT <Unsigned32>,
}

Offset: u32 = {
  OFFSET <Unsigned32>,
}

SetOperator: SetOperator = {
  UNION => SetOperator::Union,
  UNION ALL => SetOperator::UnionAll,
}

SetQuantifier: SetQuantifier = {
  ALL => SetQuantifier::All,
  DISTINCT => SetQuantifier::Distinct,
};

SelectBody: SelectBody = {
  Comma<SelectExpression> => SelectBody::Standard(<>),
  VALUE <e:Comma<SelectValuesExpression>> => SelectBody::Values(e),
};

SelectValuesExpression: SelectValuesExpression = {
  Expression => SelectValuesExpression::Expression(<>),
  SubstarExpr => SelectValuesExpression::Substar(<>),
}

SelectExpression: SelectExpression = {
  STAR => SelectExpression::Star,
  SubstarExpr => SelectExpression::Substar(<>),
  AliasedExpr => SelectExpression::Aliased(<>),
};

AliasedExpr: AliasedExpr = {
  <e:Expression> <a:(AS? <Identifier>)?> => AliasedExpr{expr:e, alias:a}
};

SubstarExpr: SubstarExpr = {
  <i:Identifier> DOT_STAR => SubstarExpr{datasource: i}
};

pub Expression: Expression = {
  Tier1Expr => *<>,
};

ArrayExpr: Vec<Expression> = {
  LEFT_BRACKET <Comma<Expression>> RIGHT_BRACKET,
};

CaseExpr: CaseExpr = {
  CASE <w:WhenBranch+> <e:ElseBranch?> END => CaseExpr{expr:None, when_branch:w, else_branch:e},
  CASE <expr:Expression> <w:WhenBranch+> <e:ElseBranch?> END => CaseExpr{expr:Some(Box::new(expr)), when_branch:w, else_branch:e},
}

WhenBranch: WhenBranch = {
  WHEN <e1:Expression> THEN <e2:Expression> => WhenBranch{when:Box::new(e1), then:Box::new(e2)},
}

ElseBranch: Box<Expression> = {
  ELSE <e:Expression> => Box::new(e),
}

SubqueryQuantifier: SubqueryQuantifier = {
  ANY => SubqueryQuantifier::Any,
  SOME => SubqueryQuantifier::Any,
  ALL => SubqueryQuantifier::All,
}

SubqueryExpr: Box<Query> = {
  LEFT_PAREN <s:Query> RIGHT_PAREN => Box::new(s),
}

ExistsExpr: Expression = {
  EXISTS <s:SubqueryExpr> => Expression::Exists(s)
}

FunctionExpr: FunctionExpr = {
  <i:ID> LEFT_PAREN <e:Comma<Expression>> RIGHT_PAREN => FunctionExpr{function:FunctionName(i.to_string()), args:e.iter().map(|x| FunctionArg::Expr(x.clone())).collect()},
  Cast,
  CurrentTimestamp,
  Extract,
  Fold,
  Position,
  Substring,
  Trim,
}

Cast: FunctionExpr = {
  CAST LEFT_PAREN <ex:Expression> AS <t:Type> RIGHT_PAREN => FunctionExpr{function:FunctionName("CAST".to_string()), args:vec![FunctionArg::Expr(ex), FunctionArg::Cast(t)]},
  CAST LEFT_PAREN <ex:Expression> AS <t:Type> <n:(COMMA <Expression> ON NULL)> RIGHT_PAREN => FunctionExpr{function:FunctionName("CAST".to_string()), args:vec![FunctionArg::Expr(ex), FunctionArg::Cast(t), FunctionArg::Expr(n)]},
  CAST LEFT_PAREN <ex:Expression> AS <t:Type> <e:(COMMA <Expression> ON ERROR)> RIGHT_PAREN => FunctionExpr{function:FunctionName("CAST".to_string()), args:vec![FunctionArg::Expr(ex), FunctionArg::Cast(t), FunctionArg::Expr(e)]},
  CAST LEFT_PAREN <ex:Expression> AS <t:Type> <n:(COMMA <Expression> ON NULL)> <e:(COMMA <Expression> ON ERROR)> RIGHT_PAREN => FunctionExpr{function:FunctionName("CAST".to_string()), args:vec![FunctionArg::Expr(ex), FunctionArg::Cast(t), FunctionArg::Expr(n), FunctionArg::Expr(e)]},
}

CurrentTimestamp: FunctionExpr = {
  CURRENT_TIMESTAMP <e:(LEFT_PAREN <Expression> RIGHT_PAREN)?> => match e {
    Some(e) => FunctionExpr{function: FunctionName("CURRENT_TIMESTAMP".to_string()), args:vec![FunctionArg::Expr(e)]},
    None => FunctionExpr{function: FunctionName("CURRENT_TIMESTAMP".to_string()), args:vec![]},
  }
}

ExtractSpec: ExtractSpec = {
  TIMEZONE_HOUR => ExtractSpec::TimezoneHour,
  TIMEZONE_MINUTE => ExtractSpec::TimezoneMinute,
  YEAR => ExtractSpec::Year,
  MONTH => ExtractSpec::Month,
  DAY => ExtractSpec::Day,
  HOUR => ExtractSpec::Hour,
  MINUTE => ExtractSpec::Minute,
  SECOND => ExtractSpec::Second,
}

Extract: FunctionExpr = {
  EXTRACT LEFT_PAREN <f:ExtractSpec> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("EXTRACT".to_string()), args:vec![FunctionArg::Extract(f), FunctionArg::Expr(e)]},
}

Casing: Casing = {
  UPPER => Casing::Upper,
  LOWER => Casing::Lower,
}

Fold: FunctionExpr = {
  <c:Casing> LEFT_PAREN <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("FOLD".to_string()), args:vec![FunctionArg::Fold(c), FunctionArg::Expr(e)]},
}

// This production uses `Tier4Expr` instead of `Expression IN Expression` to avoid
// shift-reduce conflicts with IN predicate subqueries.
Position: FunctionExpr = {
  POSITION LEFT_PAREN <e:Tier4Expr> RIGHT_PAREN =>? parse_position_func(*e),
}

Substring: FunctionExpr = {
  SUBSTRING LEFT_PAREN <e1:Expression> FROM <e2:Expression> <e3:(FOR <Expression>)?> RIGHT_PAREN => match e3 {
    Some(e3) => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2), FunctionArg::Expr(e3)]},
    None => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2)]},
  },
  SUBSTRING LEFT_PAREN <e1:Expression> COMMA <e2:Expression> <e3:(COMMA <Expression>)?> RIGHT_PAREN => match e3 {
    Some(e3) => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2), FunctionArg::Expr(e3)]},
    None => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2)]},
  }
}

TrimSpec: TrimSpec = {
  LEADING => TrimSpec::Leading,
  TRAILING => TrimSpec::Trailing,
  BOTH => TrimSpec::Both,
}

Trim: FunctionExpr = {
  TRIM LEFT_PAREN <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(TrimSpec::Both), FunctionArg::Expr(Expression::Identifier(" ".to_string())), FunctionArg::Expr(e)]},
  TRIM LEFT_PAREN <s:TrimSpec> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(s), FunctionArg::Expr(Expression::Identifier(" ".to_string())), FunctionArg::Expr(e)]},
  TRIM LEFT_PAREN <substr:Expression> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(TrimSpec::Both), FunctionArg::Expr(substr), FunctionArg::Expr(e)]},
  TRIM LEFT_PAREN <s:TrimSpec> <substr:Expression> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(s), FunctionArg::Expr(substr), FunctionArg::Expr(e)]},
}

DocumentExpr: Expression = {
  LEFT_CURLY_BRACE <l:Comma<(<String> COLON <Expression>)>> RIGHT_CURLY_BRACE => Expression::Document(l.into_iter().collect())
}

// This production uses Tier12Expr instead of Expression to avoid shift-reduce conflicts
// with other Expressions. We're specifically using Tier12Expr because the LHS cannot be
// a Binary or Unary expr.
AccessExpr: AccessExpr = {
  <e:Tier12Expr> LEFT_BRACKET <s:Expression> RIGHT_BRACKET => AccessExpr{expr:e, subfield:Box::new(s)},
}

Identifier: String = {
  ID => <>.to_string(),
  DELIMITED_IDENT_QUOTE => process_delimited_ident(<>),
  DELIMITED_IDENT_BACKTICK => process_delimited_ident(<>),
};

Tuple: Expression = {
  LEFT_PAREN <e:Expression> COMMA <l:Comma<Expression>> RIGHT_PAREN => {
    let mut e = vec![e];
    e.extend(l);
    Expression::Tuple(e)
  }
}

BinaryTier<Op,NextTier>: Box<Expression> = {
  <left:BinaryTier<Op,NextTier>> <op:Op> <right:NextTier> => Box::new(Expression::Binary(BinaryExpr{<>})),
  NextTier
};

UnaryTier<Op,NextTier>: Box<Expression> = {
  <op:Op> <expr:UnaryTier<Op, NextTier>> => Box::new(Expression::Unary(UnaryExpr{<>})),
  NextTier
};

// ComparisonTier parses (1) binary expressions that include a comparison operator and
// (2) subquery comparison expressions. We need to declare an order of precedence for
// these expressions to avoid shift-reduce conflicts with CompareOps.
ComparisonTier<Expr, Op, NextTier>: Box<Expression> = {
  <left:ComparisonTier<Expr, Op,NextTier>> <op:Op> <right:NextTier> => Box::new(Expression::Binary(BinaryExpr{<>})),
  <expr:ComparisonTier<Expr, Op, NextTier>> <op:Op> <quantifier:SubqueryQuantifier> <subquery:SubqueryExpr> => Box::new(Expression::SubqueryComparison(SubqueryComparisonExpr{<>})),
  NextTier
};

// The following tiers were created in order to avoid shift-reduce conflicts with productions
// that start with <Expression>.

// TypeTier parses (1) type conversion expressions that use the shorthand `::` notation and
// (2) type assertion expressions.
TypeTier<Expr, NextTier>: Box<Expression> = {
  <e:TypeTier<Expr, NextTier>> DOUBLE_COLON <t:Type> => Box::new(Expression::Function(FunctionExpr{function:FunctionName("CAST".to_string()), args:vec![FunctionArg::Expr(*e), FunctionArg::Cast(t)]})),
  <e:TypeTier<Expr, NextTier>> TYPE_ASSERTION <t:Type> => Box::new(Expression::TypeAssertion(TypeAssertionExpr{expr:e, target_type:t})),
  NextTier,
};

BetweenTier<Expr, NextTier>: Box<Expression> = {
  <e1:BetweenTier<Expr, NextTier>> BETWEEN <e2:NextTier> =>? parse_between_expr(e1, *e2, false),
  <e1:BetweenTier<Expr, NextTier>> <n:NotOp> BETWEEN <e2:NextTier> =>? parse_between_expr(e1, *e2, true),
  NextTier,
}

SubpathTier<Expr, NextTier>: Box<Expression> = {
  <expr:SubpathTier<Expr, NextTier>> DOT <subpath:Identifier> => Box::new(Expression::Subpath(SubpathExpr{<>})),
  NextTier
};

IsTier<Expression,NextTier>: Box<Expression> = {
  <e:IsTier<Expression,NextTier>> IS <t:Type> => Box::new(Expression::Is(IsExpr{expr:e, target_type:TypeOrMissing::Type(t)})),
  <e:IsTier<Expression,NextTier>> IS NOT <t:Type> => Box::new(Expression::Unary(UnaryExpr{op:UnaryOp::Not, expr:Box::new(Expression::Is(IsExpr{expr:e, target_type:TypeOrMissing::Type(t)}))})),
  <e:IsTier<Expression,NextTier>> IS MISSING => Box::new(Expression::Is(IsExpr{expr:e, target_type:TypeOrMissing::Missing})),
  <e:IsTier<Expression,NextTier>> IS NOT MISSING => Box::new(Expression::Unary(UnaryExpr{op:UnaryOp::Not, expr:Box::new(Expression::Is(IsExpr{expr:e, target_type:TypeOrMissing::Missing}))})),
  NextTier
}

LikeTier<Expr, NextTier>: Box<Expression> = {
  <e1:LikeTier<Expr, NextTier>> LIKE <e2:NextTier> <s:(ESCAPE <String>)?> => Box::new(Expression::Like(LikeExpr{expr:e1, pattern:e2, escape:s})),
  <e1:LikeTier<Expr, NextTier>> NOT_LIKE <e2:NextTier> <s:(ESCAPE <String>)?> => Box::new(Expression::Unary(UnaryExpr{op:UnaryOp::Not, expr:Box::new(Expression::Like(LikeExpr{expr:e1, pattern:e2, escape:s}))})),
  NextTier,
}

Tier1Expr = LikeTier<Expression, Tier2Expr>;
Tier2Expr = IsTier<Expression, Tier3Expr>;
Tier3Expr = BetweenTier<Expression, Tier4Expr>;
Tier4Expr = BinaryTier<InOp, Tier5Expr>;
Tier5Expr = BinaryTier<OrOp, Tier6Expr>;
Tier6Expr = BinaryTier<AndOp, Tier7Expr>;
Tier7Expr = ComparisonTier<Expression, CompareOp, Tier8Expr>;
Tier8Expr = BinaryTier<ConcatOp, Tier9Expr>;
Tier9Expr = BinaryTier<AddOp, Tier10Expr>;
Tier10Expr = BinaryTier<MulOp, Tier11Expr>;
Tier11Expr = UnaryTier<UnaryOp, Tier12Expr>;
Tier12Expr = TypeTier<Expression, Tier13Expr>;
Tier13Expr = SubpathTier<Expression, BottomExpr>;

BottomExpr: Box<Expression> = {
  AccessExpr => Box::new(Expression::Access(<>)),
  ArrayExpr => Box::new(Expression::Array(<>)),
  CaseExpr => Box::new(Expression::Case(<>)),
  DocumentExpr => Box::new(<>),
  ExistsExpr => Box::new(<>),
  FunctionExpr => Box::new(Expression::Function(<>)),
  Identifier => Box::new(Expression::Identifier(<>)),
  Literal => Box::new(Expression::Literal(<>)),
  SubqueryExpr => Box::new(Expression::Subquery(<>)),
  Tuple => Box::new(<>),
  LEFT_PAREN <e:Expression> RIGHT_PAREN => Box::new(<>),
};

InOp: BinaryOp = {
  IN => BinaryOp::In,
  NOT_IN => BinaryOp::NotIn,
}

OrOp: BinaryOp = {
  OR => BinaryOp::Or,
};

AndOp: BinaryOp = {
  AND  => BinaryOp::And,
};

CompareOp: BinaryOp = {
  EQ => BinaryOp::Eq,
  NEQ => BinaryOp::Neq,
  LTE => BinaryOp::Lte,
  GTE => BinaryOp::Gte,
  LT  => BinaryOp::Lt,
  GT  => BinaryOp::Gt,
}

BoolOp: BinaryOp = {
  OrOp,
  AndOp,
  CompareOp,
}

ConcatOp: BinaryOp = {
  CONCAT => BinaryOp::Concat,
}

AddOp: BinaryOp = {
  ADD => BinaryOp::Add,
  SUB => BinaryOp::Sub,
};

MulOp: BinaryOp = {
  STAR => BinaryOp::Mul,
  DIV => BinaryOp::Div,
};

NotOp: UnaryOp = {
  NOT => UnaryOp::Not
}

UnaryOp: UnaryOp = {
  ADD => UnaryOp::Pos,
  SUB => UnaryOp::Neg,
  NotOp,
}

Literal: Literal = {
  NULL => Literal::Null,
  Boolean => Literal::Boolean(<>),
  String => Literal::String(<>),
  Integer,
  Double,
}

Boolean: bool = {
  TRUE => true,
  FALSE => false,
}

String: String = {
  <s:STRING> => s[1..s.len() - 1].replace("\'\'", "\'")
}

Integer: Literal = {
  INT =>? {
    i64::from_str(<>).map(|long| {
      if let Ok(int) = i32::try_from(long) {
        Literal::Integer(int)
      } else {
        Literal::Long(long)
      }
    }).or(Err(ParseError::from("failed to parse integer".to_string())))
  }
}

Double: Literal = {
  DOUBLE =>? {
     let d: Result<f64, ParseError<usize, Token, String>> =
       f64::from_str(<>)
           .map_err(|_| ParseError::from("failed to convert number to f64".to_string()));
     match d {
       Ok(x) => Ok(Literal::Double(x)),
       Err(x) => Err(x)
     }
   },
}

Unsigned32: u32 = {
  INT =>? {
    let u: Result<u32, ParseError<usize, Token, String>> =
      u32::from_str(<>)
          .map_err(|_| ParseError::from("failed to convert number to u32".to_string()));
    match u {
      Ok(x) => Ok(x),
      Err(x) => Err(x)
    }
  },
}

Type: Type = {
  BooleanType,
  DatetimeType,
  Decimal128Type,
  DoubleType,
  Int32Type,
  StringType,
  DOCUMENT => Type::Document,
  ARRAY => Type::Array,
  BINDATA => Type::BinData,
  UNDEFINED => Type::Undefined,
  OBJECTID => Type::ObjectId,
  NULL => Type::Null,
  REGEX => Type::RegularExpression,
  DBPOINTER => Type::DbPointer,
  JAVASCRIPT => Type::Javascript,
  SYMBOL => Type::Symbol,
  JAVASCRIPT_WITH_SCOPE => Type::JavascriptWithScope,
  BSON_TIMESTAMP => Type::Timestamp,
  LONG => Type::Int64,
  MINKEY => Type::MinKey,
  MAXKEY => Type::MaxKey,
}

Int32Type: Type = {
  INT_TYPE => Type::Int32,
  INTEGER => Type::Int32,
  SMALLINT => Type::Int32,
}

Decimal128Type: Type = {
  DECIMAL <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::Decimal128(<>),
  DEC <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::Decimal128(<>),
  NUMERIC <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::Decimal128(<>),
}

DoubleType: Type = {
  DOUBLE_TYPE PRECISION? => Type::Double(None),
  REAL => Type::Double(None),
  FLOAT <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::Double(<>),
}

StringType: Type = {
  STRING_TYPE => Type::String(None),
  VARCHAR <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::String(<>),
  CHAR <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::String(<>),
  CHARACTER <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::String(<>),
  CHAR_VARYING <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::String(<>),
  CHARACTER_VARYING <i:(LEFT_PAREN <Unsigned32> RIGHT_PAREN)?> => Type::String(<>),
}

BooleanType: Type = {
  BOOL => Type::Boolean,
  BIT => Type::Boolean,
  BOOLEAN => Type::Boolean,
}

DatetimeType: Type = {
  BSON_DATE => Type::Datetime,
  TIMESTAMP => Type::Datetime,
}

Comma<T>: Vec<T> = {
    <v:(<T> COMMA)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

match {
  r"(?i)select" => SELECT,
  "+" => ADD,
  ":" => COLON,
  "," => COMMA,
  "||" => CONCAT,
  "/" => DIV,
  "." => DOT,
  ".*" => DOT_STAR,
  "::" => DOUBLE_COLON,
  "=" => EQ,
  ">" => GT,
  ">=" => GTE,
  "[" => LEFT_BRACKET,
  "{" => LEFT_CURLY_BRACE,
  "(" => LEFT_PAREN,
  "<" => LT,
  "<=" => LTE,
  "<>" => NEQ,
  "]" => RIGHT_BRACKET,
  "}" => RIGHT_CURLY_BRACE,
  ")" => RIGHT_PAREN,
  "*" => STAR,
  "-" => SUB,
  "::!" => TYPE_ASSERTION,
  r"(?i)all" => ALL,
  r"(?i)and" => AND,
  r"(?i)any" => ANY,
  r"(?i)array" => ARRAY,
  r"(?i)as" => AS,
  r"(?i)asc" => ASC,
  r"(?i)between" => BETWEEN,
  r"(?i)bindata" => BINDATA,
  r"(?i)bit" => BIT,
  r"(?i)bool" => BOOL,
  r"(?i)boolean" => BOOLEAN,
  r"(?i)both" => BOTH,
  r"(?i)bson_date" => BSON_DATE,
  r"(?i)bson_timestamp" => BSON_TIMESTAMP,
  r"(?i)by" => BY,
  r"(?i)case" => CASE,
  r"(?i)cast" => CAST,
  r"(?i)char" => CHAR,
  r"(?i)character" => CHARACTER,
  r"(?i)char varying" => CHAR_VARYING,
  r"(?i)character varying" => CHARACTER_VARYING,
  r"(?i)cross" => CROSS,
  r"(?i)current_timestamp" => CURRENT_TIMESTAMP,
  r"(?i)day" => DAY,
  r"(?i)dbpointer" => DBPOINTER,
  r"(?i)dec" => DEC,
  r"(?i)decimal" => DECIMAL,
  r"(?i)desc" => DESC,
  r"(?i)distinct" => DISTINCT,
  r"(?i)document" => DOCUMENT,
  r"(?i)double" => DOUBLE_TYPE,
  r"(?i)else" => ELSE,
  r"(?i)end" => END,
  r"(?i)error" => ERROR,
  r"(?i)escape" => ESCAPE,
  r"(?i)exists" => EXISTS,
  r"(?i)extract" => EXTRACT,
  r"(?i)false" => FALSE,
  r"(?i)float" => FLOAT,
  r"(?i)for" => FOR,
  r"(?i)from" => FROM,
  r"(?i)hour" => HOUR,
  r"(?i)in" => IN,
  r"(?i)inner" => INNER,
  r"(?i)int" => INT_TYPE,
  r"(?i)integer" => INTEGER,
  r"(?i)is" => IS,
  r"(?i)javascript" => JAVASCRIPT,
  r"(?i)javascriptwithscope" => JAVASCRIPT_WITH_SCOPE,
  r"(?i)join" => JOIN,
  r"(?i)leading" => LEADING,
  r"(?i)like" => LIKE,
  r"(?i)left" => LEFT,
  r"(?i)limit" => LIMIT,
  r"(?i)long" => LONG,
  r"(?i)lower" => LOWER,
  r"(?i)maxkey" => MAXKEY,
  r"(?i)minkey" => MINKEY,
  r"(?i)minute" => MINUTE,
  r"(?i)missing" => MISSING,
  r"(?i)month" => MONTH,
  r"(?i)not" => NOT,
  r"(?i)not\s+in" => NOT_IN,
  r"(?i)not\s+like" => NOT_LIKE,
  r"(?i)null" => NULL,
  r"(?i)numeric" => NUMERIC,
  r"(?i)objectid" => OBJECTID,
  r"(?i)offset" => OFFSET,
  r"(?i)on" => ON,
  r"(?i)or" => OR,
  r"(?i)order" => ORDER,
  r"(?i)outer" => OUTER,
  r"(?i)position" => POSITION,
  r"(?i)precision" => PRECISION,
  r"(?i)real" => REAL,
  r"(?i)regex" => REGEX,
  r"(?i)right" => RIGHT,
  r"(?i)second" => SECOND,
  r"(?i)smallint" => SMALLINT,
  r"(?i)some" => SOME,
  r"(?i)string" => STRING_TYPE,
  r"(?i)substring" => SUBSTRING,
  r"(?i)symbol" => SYMBOL,
  r"(?i)then" => THEN,
  r"(?i)timestamp" => TIMESTAMP,
  r"(?i)timezone_hour" => TIMEZONE_HOUR,
  r"(?i)timezone_minute" => TIMEZONE_MINUTE,
  r"(?i)trailing" => TRAILING,
  r"(?i)trim" => TRIM,
  r"(?i)true" => TRUE,
  r"(?i)undefined" => UNDEFINED,
  r"(?i)union" => UNION,
  r"(?i)upper" => UPPER,
  r"(?i)values?" => VALUE,
  r"(?i)varchar" => VARCHAR,
  r"(?i)when" => WHEN,
  r"(?i)where" => WHERE,
  r"(?i)year" => YEAR,
  r"[0-9]+" => INT,
  r#"'([^\x00']|'')*'"# => STRING,
} else {
  r"[A-Za-z_][A-Za-z0-9_]*" => ID,
  r#""([^\x00"]|"")*""# => DELIMITED_IDENT_QUOTE,
  r"`([^\x00`]|``)*`" => DELIMITED_IDENT_BACKTICK,
  r"([0-9]*\.[0-9]+|[0-9]+(\.)?)([Ee](\+|\-)?[0-9]+)?([0-9]+)?" => DOUBLE,
} else {
  // NUM_PREFIXED_IDENT conflicts with the keywords in the match block, and NUM_PREFIXED_COMPOUND_IDENT
  // conflicts with DOUBLE in the else block.
  r"[0-9]*[A-Za-z_][A-Za-z0-9_]*" => NUM_PREFIXED_IDENT,
  r"[0-9]+\.[A-Za-z][A-Za-z0-9_]*" => NUM_PREFIXED_COMPOUND_IDENT,
}
