use crate::parser::ast::*;
use crate::parser::util::*;
use lalrpop_util::ParseError;
use std::str::FromStr;
use std::convert::TryFrom;

grammar;

pub Query: Query = {
  SetQuery => Query::Set(<>),
	SelectQuery => Query::Select(<>),
};

SetQuery: SetQuery = {
  <q:Query> <o:SetOperator> <s:SelectQuery>  => SetQuery{left:Box::new(q), op:o, right:Box::new(Query::Select(s))},
}

SelectQuery: SelectQuery = {
  <s:SelectClause> <o:OrderByClause?> => SelectQuery{select_clause:s, order_by_clause: o},
};

SelectClause: SelectClause = {
  SELECT <q:SetQuantifier?> <b:SelectBody> => SelectClause{set_quantifier:q.unwrap_or(SetQuantifier::All), body:b},
}

OrderByClause: OrderByClause = {
  ORDER BY <s:Comma<SortSpec>> => OrderByClause{sort_specs:s},
}

SortSpec: SortSpec = {
  <k:SortKey> <d:SortDirection?> => SortSpec{key:k, direction:d.unwrap_or(SortDirection::Asc)},
}

SortKey: SortKey = {
  Identifier => SortKey::Simple(<>),
  INT =>? {
    let i: Result<u32, ParseError<usize, Token, &str>> = u32::from_str(<>).map_err(|_| ParseError::from("failed to convert to unsigned int"));
    match i {
      Ok(x) => Ok(SortKey::Positional(x)),
      Err(x) => Err(x)
    }
  },
}

SortDirection: SortDirection = {
  ASC => SortDirection::Asc,
  DESC => SortDirection::Desc,
}

SetOperator: SetOperator = {
  UNION => SetOperator::Union,
  UNION ALL => SetOperator::UnionAll,
}

SetQuantifier: SetQuantifier = {
  ALL => SetQuantifier::All,
  DISTINCT => SetQuantifier::Distinct,
};

SelectBody: SelectBody = {
  Comma<SelectExpression> => SelectBody::Standard(<>),
  VALUE <e:Comma<SelectValuesExpression>> => SelectBody::Values(e),
};

SelectValuesExpression: SelectValuesExpression = {
  Expression => SelectValuesExpression::Expression(<>),
  SubstarExpression => SelectValuesExpression::Substar(<>),
}

SelectExpression: SelectExpression = {
  STAR => SelectExpression::Star,
  SubstarExpression => SelectExpression::Substar(<>),
  AliasedExpression => SelectExpression::Aliased(<>),
};

SubstarExpression: SubstarExpression = {
  <i:SimpleIdentifier> DOT STAR => SubstarExpression{datasource: i}
};

AliasedExpression: AliasedExpression = {
  <e:Expression> <s:(AS? <SimpleIdentifier>)?> => AliasedExpression{expression:e, alias:s}
};

pub Expression: Expression = {
  Tier1Expr => *<>,
  BetweenExpr,
  CaseExpr => Expression::Case(<>),
  FunctionExpr => Expression::Function(<>),
};

BetweenExpr: Expression = {
  <e:Expression> BETWEEN <l:Tier3Expr> AND <r:Tier3Expr> => Expression::Between(BetweenExpr{expr:Box::new(e), min:l, max:r}),
  <e:Expression> <n:NotOp> BETWEEN <l:Tier3Expr> AND <r:Tier3Expr>  => Expression::Unary(UnaryExpr{op:n, expr:Box::new(Expression::Between(BetweenExpr{expr:Box::new(e), min:l, max:r}))}),
}

CaseExpr: CaseExpr = {
  CASE <w:WhenBranch+> <e:ElseBranch?> END => CaseExpr{expr:None, when_branch:w, else_branch:e},
  CASE <expr:Expression> <w:WhenBranch+> <e:ElseBranch?> END => CaseExpr{expr:Some(Box::new(expr)), when_branch:w, else_branch:e},
}

WhenBranch: WhenBranch = {
  WHEN <e1:Tier4Expr> <o:BoolOp> <e2:Tier4Expr> THEN <e3:Expression> => WhenBranch{when:Box::new(Expression::Binary(BinaryExpr{left:e1, op:o, right:e2})), then:Box::new(e3)},
}

ElseBranch: Box<Expression> = {
  ELSE <e:Expression> => Box::new(e),
}

FunctionExpr: FunctionExpr = {
  <i:ID> LEFT_PAREN <e:Comma<Expression>> RIGHT_PAREN => FunctionExpr{function:FunctionName(i.to_string()), args:e.iter().map(|x| FunctionArg::Expr(x.clone())).collect()},
  Position,
  Extract,
  Substring,
  Fold,
  Trim,
  CurrentTimestamp,
}

Position: FunctionExpr = {
  POSITION LEFT_PAREN <e1:Expression> IN <e2:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("POSITION".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2)]},
}

ExtractSpec: ExtractSpec = {
  TIMEZONE_HOUR => ExtractSpec::TimezoneHour,
  TIMEZONE_MINUTE => ExtractSpec::TimezoneMinute,
  YEAR => ExtractSpec::Year,
  MONTH => ExtractSpec::Month,
  DAY => ExtractSpec::Day,
  HOUR => ExtractSpec::Hour,
  MINUTE => ExtractSpec::Minute,
  SECOND => ExtractSpec::Second,
}

Extract: FunctionExpr = {
  EXTRACT LEFT_PAREN <f:ExtractSpec> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("EXTRACT".to_string()), args:vec![FunctionArg::Extract(f), FunctionArg::Expr(e)]},
}

Substring: FunctionExpr = {
  SUBSTRING LEFT_PAREN <e1:Expression> FROM <e2:Expression> <e3:(FOR <Expression>)?> RIGHT_PAREN => match e3 {
    Some(e3) => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2), FunctionArg::Expr(e3)]},
    None => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2)]},
  },
  SUBSTRING LEFT_PAREN <e1:Expression> COMMA <e2:Expression> <e3:(COMMA <Expression>)?> RIGHT_PAREN => match e3 {
    Some(e3) => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2), FunctionArg::Expr(e3)]},
    None => FunctionExpr{function:FunctionName("SUBSTRING".to_string()), args:vec![FunctionArg::Expr(e1), FunctionArg::Expr(e2)]},
  }
}

Casing: Casing = {
  UPPER => Casing::Upper,
  LOWER => Casing::Lower,
}

Fold: FunctionExpr = {
  <c:Casing> LEFT_PAREN <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("FOLD".to_string()), args:vec![FunctionArg::Fold(c), FunctionArg::Expr(e)]},
}

TrimSpec: TrimSpec = {
  LEADING => TrimSpec::Leading,
  TRAILING => TrimSpec::Trailing,
  BOTH => TrimSpec::Both,
}

Trim: FunctionExpr = {
  TRIM LEFT_PAREN <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(TrimSpec::Both), FunctionArg::Expr(Expression::Identifier(Identifier::Simple(" ".to_string()))), FunctionArg::Expr(e)]},
  TRIM LEFT_PAREN <s:TrimSpec> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(s), FunctionArg::Expr(Expression::Identifier(Identifier::Simple(" ".to_string()))), FunctionArg::Expr(e)]},
  TRIM LEFT_PAREN <substr:Expression> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(TrimSpec::Both), FunctionArg::Expr(substr), FunctionArg::Expr(e)]},
  TRIM LEFT_PAREN <s:TrimSpec> <substr:Expression> FROM <e:Expression> RIGHT_PAREN => FunctionExpr{function:FunctionName("TRIM".to_string()), args:vec![FunctionArg::Trim(s), FunctionArg::Expr(substr), FunctionArg::Expr(e)]},
}

CurrentTimestamp: FunctionExpr = {
  CURRENT_TIMESTAMP <e:(LEFT_PAREN <Expression> RIGHT_PAREN)?> => match e {
    Some(e) => FunctionExpr{function: FunctionName("CURRENT_TIMESTAMP".to_string()), args:vec![FunctionArg::Expr(e)]},
    None => FunctionExpr{function: FunctionName("CURRENT_TIMESTAMP".to_string()), args:vec![]},
  }
}

Identifier: Identifier = {
  SimpleIdentifier => Identifier::Simple(<>),
  CompoundIdentifier => Identifier::Compound(<>),
};

SimpleIdentifier: String = {
  ID => <>.to_string(),
  DELIMITED_IDENT_QUOTE => process_delimited_ident(<>),
  DELIMITED_IDENT_BACKTICK => process_delimited_ident(<>),
}

CompoundIdentifier: Vec<String> = {
  <s1:SimpleIdentifier> <s2:(DOT <SimpleIdentifier>)+> => {
    let mut ids = vec![s1];
    ids.extend(s2);
    ids
  }
}

BinaryTier<Op,NextTier>: Box<Expression> = {
  <left:BinaryTier<Op,NextTier>> <op:Op> <right:NextTier> => Box::new(Expression::Binary(BinaryExpr{<>})),
  NextTier
};

UnaryTier<Op,NextTier>: Box<Expression> = {
  <op:Op> <expr:UnaryTier<Op, NextTier>> => Box::new(Expression::Unary(UnaryExpr{<>})),
  NextTier
}

Tier1Expr = BinaryTier<OrOp, Tier2Expr>;
Tier2Expr = BinaryTier<AndOp, Tier3Expr>;
Tier3Expr = BinaryTier<CompareOp, Tier4Expr>;
Tier4Expr = BinaryTier<ConcatOp, Tier5Expr>;
Tier5Expr = BinaryTier<AddOp, Tier6Expr>;
Tier6Expr = BinaryTier<MulOp, Tier7Expr>;
Tier7Expr = UnaryTier<UnaryOp, BottomExpr>;

BottomExpr: Box<Expression> = {
  Identifier => Box::new(Expression::Identifier(<>)),
  Literal => Box::new(Expression::Literal(<>)),
  LEFT_PAREN <e:Expression> RIGHT_PAREN => Box::new(e),
};

OrOp: BinaryOp = {
  OR => BinaryOp::Or,
};

AndOp: BinaryOp = {
  AND  => BinaryOp::And,
};

CompareOp: BinaryOp = {
  EQ => BinaryOp::Eq,
  NEQ => BinaryOp::Neq,
  LTE => BinaryOp::Lte,
  GTE => BinaryOp::Gte,
  LT  => BinaryOp::Lt,
  GT  => BinaryOp::Gt,
};

BoolOp: BinaryOp = {
  OrOp,
  AndOp,
  CompareOp,
}

ConcatOp: BinaryOp = {
  CONCAT => BinaryOp::Concat,
}

AddOp: BinaryOp = {
  ADD => BinaryOp::Add,
  SUB => BinaryOp::Sub,
};

MulOp: BinaryOp = {
  STAR => BinaryOp::Mul,
  DIV => BinaryOp::Div,
};

NotOp: UnaryOp = {
  NOT => UnaryOp::Not
}

UnaryOp: UnaryOp = {
  ADD => UnaryOp::Pos,
  SUB => UnaryOp::Neg,
  NotOp,
}

Literal: Literal = {
  NULL => Literal::Null,
  Boolean => Literal::Boolean(<>),
  String => Literal::String(<>),
  Integer,
  Double,
}

Boolean: bool = {
  TRUE => true,
  FALSE => false,
}

String: String = {
  <s:STRING> => s[1..s.len() - 1].replace("\'\'", "\'")
}

Integer: Literal = {
  INT =>? {
    i64::from_str(<>).map(|long| {
      if let Ok(int) = i32::try_from(long) {
        Literal::Integer(int)
      } else {
        Literal::Long(long)
      }
    }).or(Err(ParseError::from("failed to parse integer")))
  }
}

Double: Literal = {
  DOUBLE =>? {
     let d: Result<f64, ParseError<usize, Token, &str>> = f64::from_str(<>).map_err(|_| ParseError::from("failed to convert number to f64"));
     match d {
       Ok(x) => Ok(Literal::Double(x)),
       Err(x) => Err(x)
     }
   },
}

Comma<T>: Vec<T> = {
    <v:(<T> COMMA)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

match {
  r"(?i)select" => SELECT,
  "+" => ADD,
  "," => COMMA,
  "||" => CONCAT,
	"/" => DIV,
	"." => DOT,
  "=" => EQ,
  ">" => GT,
  ">=" => GTE,
  "(" => LEFT_PAREN,
  "<" => LT,
  "<=" => LTE,
	"<>" => NEQ,
	")" => RIGHT_PAREN,
	"*" => STAR,
	"-" => SUB,
	r"(?i)all" => ALL,
	r"(?i)and" => AND,
	r"(?i)as" => AS,
	r"(?i)asc" => ASC,
	r"(?i)between" => BETWEEN,
  r"(?i)both" => BOTH,
	r"(?i)by" => BY,
	r"(?i)case" => CASE,
	r"(?i)current_timestamp" => CURRENT_TIMESTAMP,
	r"(?i)day" => DAY,
	r"(?i)desc" => DESC,
	r"(?i)distinct" => DISTINCT,
	r"(?i)else" => ELSE,
	r"(?i)end" => END,
	r"(?i)extract" => EXTRACT,
	r"(?i)false" => FALSE,
	r"(?i)for" => FOR,
	r"(?i)from" => FROM,
	r"(?i)hour" => HOUR,
	r"(?i)in" => IN,
	r"(?i)leading" => LEADING,
	r"(?i)lower" => LOWER,
	r"(?i)minute" => MINUTE,
	r"(?i)missing" => MISSING,
	r"(?i)month" => MONTH,
	r"(?i)not" => NOT,
	r"(?i)null" => NULL,
	r"(?i)or" => OR,
	r"(?i)order" => ORDER,
	r"(?i)position" => POSITION,
	r"(?i)second" => SECOND,
	r"(?i)substring" => SUBSTRING,
	r"(?i)then" => THEN,
	r"(?i)timezone_hour" => TIMEZONE_HOUR,
	r"(?i)timezone_minute" => TIMEZONE_MINUTE,
	r"(?i)trailing" => TRAILING,
	r"(?i)trim" => TRIM,
	r"(?i)true" => TRUE,
	r"(?i)union" => UNION,
	r"(?i)upper" => UPPER,
	r"(?i)values?" => VALUE,
	r"(?i)when" => WHEN,
	r"(?i)year" => YEAR,
  r"[0-9]+" => INT,
  r#"'([^\x00']|'')*'"# => STRING,
} else {
  r"[A-Za-z_][A-Za-z0-9_]*" => ID,
  r#""([^\x00"]|"")*""# => DELIMITED_IDENT_QUOTE,
  r"`([^\x00`]|``)*`" => DELIMITED_IDENT_BACKTICK,
  r"([0-9]*\.[0-9]+|[0-9]+(\.)?)([Ee]?[\+\-]?[0-9]+)?" => DOUBLE,
} else {
  // NUM_PREFIXED_IDENT conflicts with the keywords in the match block
  r"[0-9]*[A-Za-z_][A-Za-z0-9_]*" => NUM_PREFIXED_IDENT,
}
