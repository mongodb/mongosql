use crate::parser::ast::*;
use crate::parser::util::*;
use lalrpop_util::ParseError;
use std::str::FromStr;
use std::convert::TryFrom;

grammar;

pub Query: Query = {
  SetQuery => Query::Set(<>),
	SelectQuery => Query::Select(<>),
};

SetQuery: SetQuery = {
  <q:Query> <o:SetOperator> <s:SelectQuery>  => SetQuery{left:Box::new(q), op:o, right:Box::new(Query::Select(s))},
}

SelectQuery: SelectQuery = {
  <s:SelectClause> <o:OrderByClause?> => SelectQuery{select_clause:s, order_by_clause: o},
};

SelectClause: SelectClause = {
  SELECT <q:SetQuantifier?> <b:SelectBody> => SelectClause{set_quantifier:q.unwrap_or(SetQuantifier::All), body:b},
}

OrderByClause: OrderByClause = {
  ORDER BY <s:Comma<SortSpec>> => OrderByClause{sort_specs:s},
}

SortSpec: SortSpec = {
  <k:SortKey> <d:SortDirection?> => SortSpec{key:k, direction:d.unwrap_or(SortDirection::Asc)},
}

SortKey: SortKey = {
  Identifier => SortKey::Key(<>),
}

SortDirection: SortDirection = {
  ASC => SortDirection::Asc,
  DESC => SortDirection::Desc,
}

SetOperator: SetOperator = {
  UNION => SetOperator::Union,
  UNION ALL => SetOperator::UnionAll,
}

SetQuantifier: SetQuantifier = {
  ALL => SetQuantifier::All,
  DISTINCT => SetQuantifier::Distinct,
};

SelectBody: SelectBody = {
  Comma<SelectExpression> => SelectBody::Standard(<>),
  VALUE <e:Comma<SelectValuesExpression>> => SelectBody::Values(e),
};

SelectValuesExpression: SelectValuesExpression = {
  Expression => SelectValuesExpression::Expression(<>),
  SubstarExpression => SelectValuesExpression::Substar(<>),
}

SelectExpression: SelectExpression = {
  STAR => SelectExpression::Star,
  SubstarExpression => SelectExpression::Substar(<>),
  AliasedExpression => SelectExpression::Aliased(<>),
};

AliasedExpression: AliasedExpression = {
  <e:Expression> <s:(AS? <SimpleIdentifier>)?> => AliasedExpression{expression:e, alias:s}
};

SubstarExpression: SubstarExpression = {
  <i:SimpleIdentifier> DOT STAR => SubstarExpression{datasource: i}
};

pub Expression: Expression = {
  Tier1Expr => *<>,
  BetweenExpr,
  CaseExpr => Expression::Case(<>),
};

BetweenExpr: Expression = {
  <e:Expression> BETWEEN <l:Tier3Expr> AND <r:Tier3Expr> => Expression::Between(BetweenExpr{expr:Box::new(e), min:l, max:r}),
  <e:Expression> <n:NotOp> BETWEEN <l:Tier3Expr> AND <r:Tier3Expr>  => Expression::Unary(UnaryExpr{op:n, expr:Box::new(Expression::Between(BetweenExpr{expr:Box::new(e), min:l, max:r}))}),
}

CaseExpr: CaseExpr = {
  CASE <w:WhenBranch+> <e:ElseBranch?> END => CaseExpr{expr:None, when_branch:w, else_branch:e},
  CASE <expr:Expression> <w:WhenBranch+> <e:ElseBranch?> END => CaseExpr{expr:Some(Box::new(expr)), when_branch:w, else_branch:e},
}

WhenBranch: WhenBranch = {
  WHEN <e1:Tier4Expr> <o:BoolOp> <e2:Tier4Expr> THEN <e3:Expression> => WhenBranch{when:Box::new(Expression::Binary(BinaryExpr{left:e1, op:o, right:e2})), then:Box::new(e3)},
}

ElseBranch: Box<Expression> = {
  ELSE <e:Expression> => Box::new(e),
}

Identifier: Identifier = {
  SimpleIdentifier => Identifier::Simple(<>),
  CompoundIdentifier => Identifier::Compound(<>),
};

SimpleIdentifier: String = {
  ID => <>.to_string(),
  DELIMITED_IDENT_QUOTE => process_delimited_ident(<>),
  DELIMITED_IDENT_BACKTICK => process_delimited_ident(<>),
}

CompoundIdentifier: Vec<String> = {
  <s1:SimpleIdentifier> <s2:(DOT <SimpleIdentifier>)+> => {
    let mut ids = vec![s1];
    ids.extend(s2);
    ids
  }
}

BinaryTier<Op,NextTier>: Box<Expression> = {
  <left:BinaryTier<Op,NextTier>> <op:Op> <right:NextTier> => Box::new(Expression::Binary(BinaryExpr{<>})),
  NextTier
};

UnaryTier<Op,NextTier>: Box<Expression> = {
  <op:Op> <expr:UnaryTier<Op, NextTier>> => Box::new(Expression::Unary(UnaryExpr{<>})),
  NextTier
}

Tier1Expr = BinaryTier<OrOp, Tier2Expr>;
Tier2Expr = BinaryTier<AndOp, Tier3Expr>;
Tier3Expr = BinaryTier<CompareOp, Tier4Expr>;
Tier4Expr = BinaryTier<ConcatOp, Tier5Expr>;
Tier5Expr = BinaryTier<AddOp, Tier6Expr>;
Tier6Expr = BinaryTier<MulOp, Tier7Expr>;
Tier7Expr = UnaryTier<UnaryOp, BottomExpr>;

BottomExpr: Box<Expression> = {
  Identifier => Box::new(Expression::Identifier(<>)),
  Literal => Box::new(Expression::Literal(<>)),
};

OrOp: BinaryOp = {
  OR => BinaryOp::Or,
};

AndOp: BinaryOp = {
  AND  => BinaryOp::And,
};

CompareOp: BinaryOp = {
  EQ => BinaryOp::Eq,
  NEQ => BinaryOp::Neq,
  LTE => BinaryOp::Lte,
  GTE => BinaryOp::Gte,
  LT  => BinaryOp::Lt,
  GT  => BinaryOp::Gt,
};

BoolOp: BinaryOp = {
  OrOp,
  AndOp,
  CompareOp,
}

ConcatOp: BinaryOp = {
  CONCAT => BinaryOp::Concat,
}

AddOp: BinaryOp = {
  ADD => BinaryOp::Add,
  SUB => BinaryOp::Sub,
};

MulOp: BinaryOp = {
  STAR => BinaryOp::Mul,
  DIV => BinaryOp::Div,
};

NotOp: UnaryOp = {
  NOT => UnaryOp::Not
}

UnaryOp: UnaryOp = {
  ADD => UnaryOp::Pos,
  SUB => UnaryOp::Neg,
  NotOp,
}

Literal: Literal = {
  NULL => Literal::Null,
  Boolean => Literal::Boolean(<>),
  String => Literal::String(<>),
  Integer,
  Double,
}

Boolean: bool = {
  TRUE => true,
  FALSE => false,
}

String: String = {
  <s:STRING> => s[1..s.len() - 1].replace("\'\'", "\'")
}

Integer: Literal = {
  INT =>? {
    i64::from_str(<>).map(|long| {
      if let Ok(int) = i32::try_from(long) {
        Literal::Integer(int)
      } else {
        Literal::Long(long)
      }
    }).or(Err(ParseError::from("failed to parse integer")))
  }
}

Double: Literal = {
  DOUBLE =>? {
     let d: Result<f64, ParseError<usize, Token, &str>> = f64::from_str(<>).map_err(|_| ParseError::from("failed to convert number to f64"));
     match d {
       Ok(x) => Ok(Literal::Double(x)),
       Err(x) => Err(x)
     }
   },
}

Comma<T>: Vec<T> = {
    <v:(<T> COMMA)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

match {
  r"(?i)select" => SELECT,
  "+" => ADD,
  "," => COMMA,
  "||" => CONCAT,
	"/" => DIV,
	"." => DOT,
  "=" => EQ,
  ">" => GT,
  ">=" => GTE,
  "<" => LT,
  "<=" => LTE,
	"<>" => NEQ,
	"*" => STAR,
	"-" => SUB,
	r"(?i)all" => ALL,
	r"(?i)and" => AND,
	r"(?i)as" => AS,
	r"(?i)asc" => ASC,
	r"(?i)between" => BETWEEN,
	r"(?i)by" => BY,
	r"(?i)case" => CASE,
	r"(?i)desc" => DESC,
	r"(?i)distinct" => DISTINCT,
	r"(?i)else" => ELSE,
	r"(?i)end" => END,
	r"(?i)false" => FALSE,
	r"(?i)missing" => MISSING,
	r"(?i)not" => NOT,
	r"(?i)null" => NULL,
	r"(?i)or" => OR,
	r"(?i)order" => ORDER,
	r"(?i)then" => THEN,
	r"(?i)true" => TRUE,
	r"(?i)union" => UNION,
	r"(?i)values?" => VALUE,
	r"(?i)when" => WHEN,
  r"[0-9]+" => INT,
  r#"'([^\x00']|'')*'"# => STRING,
} else {
  r"[A-Za-z_][A-Za-z0-9_]*" => ID,
  r#""([^\x00"]|"")*""# => DELIMITED_IDENT_QUOTE,
  r"`([^\x00`]|``)*`" => DELIMITED_IDENT_BACKTICK,
  r"([0-9]*\.[0-9]+|[0-9]+(\.)?)([Ee]?[\+\-]?[0-9]+)?" => DOUBLE,
} else {
  // NUM_PREFIXED_IDENT conflicts with the keywords in the match block
  r"[0-9]*[A-Za-z_][A-Za-z0-9_]*" => NUM_PREFIXED_IDENT,
}
