use crate::air;
use crate::air::{MQLOperator, MQLSemanticOperator};
use crate::schema::Satisfaction;
use agg_ast::definitions::{
    Expression, JoinType, LiteralValue, Lookup, LookupFrom, MatchExpr, MatchExpression,
    ProjectItem, Ref, Stage, Subquery, SubqueryExists, TaggedOperator, UntaggedOperator,
    UntaggedOperatorName, Unwind,
};
use itertools::Itertools;
use linked_hash_map::LinkedHashMap;

fn translate_pipeline(root: Option<air::Stage>, pipeline: Vec<Stage>) -> Option<air::Stage> {
    if pipeline.is_empty() {
        return root;
    }
    pipeline
        .into_iter()
        .fold(root, |acc, curr| Some((acc, curr).into()))
}

impl From<(Option<air::Stage>, Stage)> for air::Stage {
    fn from((source, ast_stage): (Option<air::Stage>, Stage)) -> Self {
        match ast_stage {
            Stage::Collection(c) => air::Stage::Collection(air::Collection {
                db: c.db,
                collection: c.collection,
            }),
            Stage::Documents(d) => {
                let array: Vec<air::Expression> = d
                    .into_iter()
                    .map(|m| Expression::Document(m).into())
                    .collect();

                air::Stage::Documents(air::Documents { array })
            }
            Stage::Project(p) => {
                let specs: LinkedHashMap<String, air::ProjectItem> = p
                    .items
                    .into_iter()
                    .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
                    .map(|(k, v)| (k, air::ProjectItem::from(v)))
                    // sort alphabetically for testing purposes
                    .collect::<_>();

                air::Stage::Project(air::Project {
                    source: Box::new(source.expect("$project without valid source stage")),
                    specifications: specs.into(),
                })
            }
            Stage::ReplaceWith(r) => air::Stage::ReplaceWith(air::ReplaceWith {
                source: Box::new(source.expect("$replaceWith without valid source stage")),
                new_root: Box::new(r.expression().into()),
            }),
            Stage::Match(mut m) => {
                let expr = if m.expr.len() == 1 {
                    match m.expr.remove(0) {
                        MatchExpression::Expr(MatchExpr { expr: e }) => Box::new((*e).into()),
                        _ => {
                            panic!("$match with non-$expr should not be generated by mongosql")
                        }
                    }
                } else {
                    panic!("$match with multiple expressions should not be generated by mongosql")
                };
                air::Stage::Match(air::Match::ExprLanguage(air::ExprLanguage {
                    source: Box::new(source.expect("$match without valid source stage")),
                    expr,
                }))
            }
            Stage::Limit(l) => air::Stage::Limit(air::Limit {
                source: Box::new(source.expect("$limit without valid source stage")),
                limit: l,
            }),
            Stage::Skip(s) => air::Stage::Skip(air::Skip {
                source: Box::new(source.expect("$skip without valid source stage")),
                skip: s,
            }),
            Stage::Sort(s) => {
                let specs = s
                    .into_iter()
                    // sort alphabetically for testing purposes -- this obviously changes sort semantics, however that doesn't matter for desugarer tests
                    .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
                    .map(|(k, v)| {
                        if v >= 1 {
                            air::SortSpecification::Asc(k)
                        } else if v <= -1 {
                            air::SortSpecification::Desc(k)
                        } else {
                            panic!("sort spec cannot be 0 but was for '{k}'")
                        }
                    })
                    .collect::<Vec<air::SortSpecification>>();

                air::Stage::Sort(air::Sort {
                    source: Box::new(source.expect("$sort without valid source stage")),
                    specs,
                })
            }
            Stage::Group(g) => {
                let keys = match g.keys {
                    // keys of form: _id: { name_1: expr_1, ... name_n, expr_n}
                    Expression::Document(d) => d
                        .into_iter()
                        .map(|(k, v)| air::NameExprPair {
                            name: k,
                            expr: v.into(),
                        })
                        .collect(),
                    // keys of form: _id: null
                    Expression::Literal(LiteralValue::Null) => vec![],
                    _ => panic!(),
                };
                let str_to_sat = |s: Option<String>| match s {
                    Some(s) if s.to_lowercase() == "must" => Satisfaction::Must,
                    Some(s) if s.to_lowercase() == "may" => Satisfaction::May,
                    _ => Satisfaction::Not,
                };
                let extract_and_convert_tagged_op = |tagged_op: TaggedOperator| match tagged_op {
                    TaggedOperator::SQLAvg(e) => (air::AggregationFunction::Avg, e),
                    TaggedOperator::SQLCount(e) => (air::AggregationFunction::Count, e),
                    TaggedOperator::SQLFirst(e) => (air::AggregationFunction::First, e),
                    TaggedOperator::SQLLast(e) => (air::AggregationFunction::Last, e),
                    TaggedOperator::SQLMax(e) => (air::AggregationFunction::Max, e),
                    TaggedOperator::SQLMergeObjects(e) => {
                        (air::AggregationFunction::MergeDocuments, e)
                    }
                    TaggedOperator::SQLMin(e) => (air::AggregationFunction::Min, e),
                    TaggedOperator::SQLStdDevPop(e) => (air::AggregationFunction::StddevPop, e),
                    TaggedOperator::SQLStdDevSamp(e) => (air::AggregationFunction::StddevSamp, e),
                    TaggedOperator::SQLSum(e) => (air::AggregationFunction::Sum, e),
                    _ => panic!("invalid accumulator expression"),
                };
                let convert_untagged_op = |u: &UntaggedOperator| match u.op {
                    UntaggedOperatorName::AddToSet => air::AggregationFunction::AddToSet,
                    UntaggedOperatorName::Avg => air::AggregationFunction::Avg,
                    UntaggedOperatorName::First => air::AggregationFunction::First,
                    UntaggedOperatorName::Last => air::AggregationFunction::Last,
                    UntaggedOperatorName::Max => air::AggregationFunction::Max,
                    UntaggedOperatorName::MergeObjects => air::AggregationFunction::MergeDocuments,
                    UntaggedOperatorName::Min => air::AggregationFunction::Min,
                    UntaggedOperatorName::Push => air::AggregationFunction::AddToArray,
                    UntaggedOperatorName::StdDevPop => air::AggregationFunction::StddevPop,
                    UntaggedOperatorName::StdDevSamp => air::AggregationFunction::StddevSamp,
                    UntaggedOperatorName::Sum => air::AggregationFunction::Sum,
                    _ => panic!("invalid accumulator expression"),
                };
                let aggregations = g
                    .aggregations
                    .into_iter()
                    .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
                    .map(|(key, accumulator_expr)| match accumulator_expr {
                        Expression::TaggedOperator(t) => {
                            let (function, expr) = extract_and_convert_tagged_op(t);
                            air::AccumulatorExpr {
                                alias: key,
                                function,
                                distinct: expr.distinct,
                                arg: Box::new(air::Expression::from(*expr.var)),
                                arg_is_possibly_doc: str_to_sat(expr.arg_is_possibly_doc),
                            }
                        }
                        Expression::UntaggedOperator(ref u) => {
                            let function = convert_untagged_op(u);
                            air::AccumulatorExpr {
                                alias: key,
                                function,
                                distinct: false,
                                arg: Box::new(air::Expression::from(u.args[0].clone())),
                                arg_is_possibly_doc: Satisfaction::Not,
                            }
                        }
                        _ => panic!("invalid accumulator expression"),
                    })
                    .collect();
                air::Stage::Group(air::Group {
                    source: Box::new(source.expect("$group without valid source stage")),
                    keys,
                    aggregations,
                })
            }
            Stage::Join(j) => {
                let join_type = match j.join_type {
                    JoinType::Inner => air::JoinType::Inner,
                    JoinType::Left => air::JoinType::Left,
                };
                let let_vars = j.let_body.map(|body| {
                    body.into_iter()
                        .map(|(k, v)| air::LetVariable {
                            name: k,
                            expr: Box::new(v.into()),
                        })
                        .collect()
                });

                // seed the right pipeline with the collection. If the db and/or collection aren't specified, use defaults
                let source_collection = make_optional_collection_stage(j.database, j.collection);

                // right source is the join pipeline
                let right = j
                    .pipeline
                    .into_iter()
                    .fold(source_collection, |air_stage, agg_ast_stage| {
                        Some(air::Stage::from((air_stage, agg_ast_stage)))
                    });

                air::Stage::Join(air::Join {
                    join_type,
                    left: Box::new(source.expect("$join without valid source stage")),
                    right: Box::new(right.unwrap()),
                    let_vars,
                    condition: j.condition.map(|expr| expr.into()),
                })
            }
            Stage::EquiJoin(eqj) => {
                let join_type = match eqj.join_type {
                    JoinType::Inner => air::JoinType::Inner,
                    JoinType::Left => air::JoinType::Left,
                };

                air::Stage::EquiJoin(air::EquiJoin {
                    join_type,
                    source: Box::new(source.expect("$equijoin without valid source stage")),
                    from: air::Collection {
                        db: eqj.database.unwrap_or_else(|| "test".to_string()),
                        collection: eqj.collection.unwrap_or_else(|| "default".to_string()),
                    },
                    local_field: eqj.local_field.into(),
                    foreign_field: eqj.foreign_field.into(),
                    as_name: eqj.as_var,
                })
            }
            Stage::Unwind(u) => match u {
                Unwind::FieldPath(path) => air::Stage::Unwind(air::Unwind {
                    source: Box::new(source.expect("$unwind without valid source stage")),
                    path: path.into(),
                    index: None,
                    outer: false,
                }),
                Unwind::Document(d) => air::Stage::Unwind(air::Unwind {
                    source: Box::new(source.expect("$unwind without valid source stage")),
                    path: (*d.path).into(),
                    index: d.include_array_index,
                    outer: d.preserve_null_and_empty_arrays.unwrap_or(false),
                }),
            },
            Stage::Lookup(Lookup::Subquery(l)) => {
                let (from_db, from_coll) = match l.from {
                    Some(LookupFrom::Collection(c)) => (None, Some(c)),
                    Some(LookupFrom::Namespace(n)) => (Some(n.db), Some(n.coll)),
                    None => (None, None),
                };
                let let_vars = l.let_body.map(|let_body| {
                    let_body
                        .into_iter()
                        // sorted for testing purposes
                        .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
                        .map(|(k, v)| air::LetVariable {
                            name: k,
                            expr: Box::new(v.into()),
                        })
                        .collect::<Vec<air::LetVariable>>()
                });

                let source_collection = make_optional_collection_stage(from_db, from_coll);
                let pipeline = l
                    .pipeline
                    .into_iter()
                    .fold(source_collection, |acc, cur| {
                        Some(air::Stage::from((acc, cur)))
                    })
                    .unwrap();

                air::Stage::Lookup(air::Lookup {
                    source: Box::new(source.expect("$lookup without valid source stage")),
                    let_vars,
                    pipeline: Box::new(pipeline),
                    as_var: l.as_var,
                })
            }
            Stage::Lookup(Lookup::Equality(eql)) => {
                let (from_db, from_coll) = match eql.from {
                    LookupFrom::Collection(c) => (None, c),
                    LookupFrom::Namespace(n) => (Some(n.db), n.coll),
                };
                air::Stage::EquiLookup(air::EquiLookup {
                    source: Box::new(source.expect("$equilookup without valid source stage")),
                    from: air::Collection {
                        db: from_db.unwrap_or_else(|| "test".to_string()),
                        collection: from_coll,
                    },
                    local_field: eql.local_field.into(),
                    foreign_field: eql.foreign_field.into(),
                    as_var: eql.as_var,
                })
            }
            Stage::AddFields(_)
            | Stage::Redact(_)
            | Stage::Unset(_)
            | Stage::SetWindowFields(_)
            | Stage::Bucket(_)
            | Stage::BucketAuto(_)
            | Stage::Count(_)
            | Stage::Densify(_)
            | Stage::Facet(_)
            | Stage::Fill(_)
            | Stage::GeoNear(_)
            | Stage::Sample(_)
            | Stage::SortByCount(_)
            | Stage::UnionWith(_)
            | Stage::GraphLookup(_)
            | Stage::AtlasSearchStage(_)
            | Stage::Lookup(Lookup::ConciseSubquery(_)) => {
                panic!("cannot convert {} stage to air", ast_stage.name())
            }
        }
    }
}

impl From<ProjectItem> for air::ProjectItem {
    fn from(ast_project_item: ProjectItem) -> Self {
        match ast_project_item {
            ProjectItem::Exclusion => air::ProjectItem::Exclusion,
            ProjectItem::Inclusion => air::ProjectItem::Inclusion,
            ProjectItem::Assignment(ast_expr) => air::ProjectItem::Assignment(ast_expr.into()),
        }
    }
}

impl From<Expression> for air::Expression {
    fn from(ast_expr: Expression) -> Self {
        match ast_expr {
            Expression::Literal(lv) => air::Expression::Literal(air::LiteralValue::from(lv)),
            Expression::Ref(v) => match v {
                Ref::FieldRef(s) => air::Expression::FieldRef(s.into()),
                Ref::VariableRef(s) => air::Expression::Variable(s.into()),
            },
            Expression::TaggedOperator(to) => to.into(),
            Expression::UntaggedOperator(uo) => uo.into(),
            Expression::Array(a) => {
                air::Expression::Array(a.into_iter().map(air::Expression::from).collect::<Vec<_>>())
            }
            Expression::Document(m) => {
                let lhm: LinkedHashMap<String, air::Expression> = m
                    .into_iter()
                    // sort alphabetically for testing purposes
                    .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
                    .map(|(k, v)| (k, air::Expression::from(v)))
                    .collect::<_>();

                air::Expression::Document(lhm.into())
            }
        }
    }
}

impl From<LiteralValue> for air::LiteralValue {
    fn from(ast_lv: LiteralValue) -> Self {
        match ast_lv {
            LiteralValue::Null => air::LiteralValue::Null,
            LiteralValue::Boolean(v) => air::LiteralValue::Boolean(v),
            LiteralValue::Int32(v) => air::LiteralValue::Integer(v),
            LiteralValue::Int64(v) => {
                if v.abs() <= i32::MAX as i64 {
                    air::LiteralValue::Integer(v as i32)
                } else {
                    air::LiteralValue::Long(v)
                }
            }
            LiteralValue::Double(v) => air::LiteralValue::Double(v),
            LiteralValue::Decimal128(v) => air::LiteralValue::Decimal128(v),
            LiteralValue::String(s) => air::LiteralValue::String(s),
            // other values in agg_ast are not used by the desugarer
            _ => panic!("invalid literal value: {:?}", ast_lv),
        }
    }
}

impl From<Box<Expression>> for Box<air::Expression> {
    fn from(e: Box<Expression>) -> Self {
        Box::new((*e).into())
    }
}

fn translate_let_bindings(
    let_bindings: LinkedHashMap<String, Expression>,
) -> Vec<air::LetVariable> {
    let_bindings
        .into_iter()
        .map(|(k, e)| air::LetVariable {
            name: k,
            expr: Box::new(e.into()),
        })
        .collect()
}

fn make_optional_collection_stage(
    db: Option<String>,
    collection: Option<String>,
) -> Option<air::Stage> {
    let db = db.unwrap_or_else(|| "test".to_string());
    let collection = collection.unwrap_or_else(|| "default".to_string());
    Some(air::Stage::Collection(air::Collection { db, collection }))
}

impl From<Subquery> for air::Subquery {
    fn from(s: Subquery) -> Self {
        air::Subquery {
            let_bindings: match s.let_bindings {
                None => vec![],
                Some(let_bindings) => translate_let_bindings(let_bindings),
            },
            output_path: s.output_path.unwrap_or_default(),
            pipeline: translate_pipeline(
                make_optional_collection_stage(s.db, s.collection),
                s.pipeline,
            )
            .expect("$subquery with empty pipeline not supported")
            .into(),
        }
    }
}

impl From<SubqueryExists> for air::SubqueryExists {
    fn from(s: SubqueryExists) -> Self {
        air::SubqueryExists {
            let_bindings: match s.let_bindings {
                None => vec![],
                Some(let_bindings) => translate_let_bindings(let_bindings),
            },
            pipeline: translate_pipeline(
                make_optional_collection_stage(s.db, s.collection),
                s.pipeline,
            )
            .expect("$subquery with empty pipeline not supported")
            .into(),
        }
    }
}

impl From<TaggedOperator> for air::Expression {
    fn from(ast_op: TaggedOperator) -> Self {
        match ast_op {
            TaggedOperator::GetField(gf) => air::Expression::GetField(air::GetField {
                field: gf.field,
                input: gf.input.into(),
            }),
            TaggedOperator::SetField(sf) => air::Expression::SetField(air::SetField {
                field: sf.field,
                input: sf.input.into(),
                value: sf.value.into(),
            }),
            TaggedOperator::UnsetField(uf) => air::Expression::UnsetField(air::UnsetField {
                field: uf.field,
                input: uf.input.into(),
            }),
            TaggedOperator::Switch(s) => air::Expression::Switch(air::Switch {
                branches: s
                    .branches
                    .into_iter()
                    .map(|b| air::SwitchCase {
                        case: b.case.into(),
                        then: b.then.into(),
                    })
                    .collect(),
                default: s.default.into(),
            }),
            TaggedOperator::Let(l) => air::Expression::Let(air::Let {
                vars: l
                    .vars
                    .into_iter()
                    // sort alphabetically for testing purposes
                    .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
                    .map(|(k, v)| air::LetVariable {
                        name: k,
                        expr: Box::new(v.into()),
                    })
                    .collect(),
                inside: l.inside.into(),
            }),
            TaggedOperator::Regex(r) => air::Expression::RegexMatch(air::RegexMatch {
                input: r.input.into(),
                regex: r.regex.into(),
                options: r.options.map(|o| o.into()),
            }),
            TaggedOperator::SQLConvert(c) => {
                let target_type = match c.to.as_str() {
                    "array" => air::SqlConvertTargetType::Array,
                    "object" => air::SqlConvertTargetType::Document,
                    _ => panic!("invalid '$sqlConvert' target type '{}'", c.to),
                };

                air::Expression::SqlConvert(air::SqlConvert {
                    input: c.input.into(),
                    to: target_type,
                    on_null: c.on_null.into(),
                    on_error: c.on_error.into(),
                })
            }
            TaggedOperator::Convert(c) => match (*c.to, c.on_null, c.on_error) {
                (Expression::Literal(LiteralValue::String(s)), Some(on_null), Some(on_error)) => {
                    air::Expression::Convert(air::Convert {
                        input: c.input.into(),
                        to: str_to_air_type(s),
                        on_null: on_null.into(),
                        on_error: on_error.into(),
                    })
                }
                _ => panic!("invalid '$' target type"),
            },
            TaggedOperator::Like(l) => air::Expression::Like(air::Like {
                expr: l.input.into(),
                pattern: l.pattern.into(),
                escape: l.escape,
            }),
            TaggedOperator::SQLDivide(d) => air::Expression::SqlDivide(air::SqlDivide {
                dividend: d.dividend.into(),
                divisor: d.divisor.into(),
                on_error: d.on_error.into(),
            }),
            TaggedOperator::Subquery(s) => air::Expression::Subquery(s.into()),
            TaggedOperator::SubqueryComparison(sc) => {
                let (op, op_type) = str_to_air_sqcop(&sc.op)
                    .unwrap_or_else(|| panic!("found bad subquery comparison op: {}", sc.op));
                air::Expression::SubqueryComparison(air::SubqueryComparison {
                    op,
                    op_type,
                    modifier: str_to_air_sqcmod(&sc.modifier)
                        .unwrap_or_else(|| panic!("found bad subquery modifier: {}", sc.modifier)),
                    arg: sc.arg.into(),
                    subquery: Box::new((*sc.subquery).into()),
                })
            }
            TaggedOperator::SubqueryExists(se) => air::Expression::SubqueryExists(se.into()),
            TaggedOperator::Trim(t) => air::Expression::Trim(air::Trim {
                op: air::TrimOperator::Trim,
                input: t.input.into(),
                chars: t
                    .chars
                    .unwrap_or(Box::new(Expression::Literal(LiteralValue::String(
                        " ".to_string(),
                    ))))
                    .into(),
            }),
            TaggedOperator::LTrim(lt) => air::Expression::Trim(air::Trim {
                op: air::TrimOperator::LTrim,
                input: lt.input.into(),
                chars: lt
                    .chars
                    .unwrap_or(Box::new(Expression::Literal(LiteralValue::String(
                        " ".to_string(),
                    ))))
                    .into(),
            }),
            TaggedOperator::RTrim(rt) => air::Expression::Trim(air::Trim {
                op: air::TrimOperator::RTrim,
                input: rt.input.into(),
                chars: rt
                    .chars
                    .unwrap_or(Box::new(Expression::Literal(LiteralValue::String(
                        " ".to_string(),
                    ))))
                    .into(),
            }),
            // Array operators
            TaggedOperator::Map(m) => air::Expression::Map(air::Map {
                input: m.input.into(),
                as_name: m._as,
                inside: m.inside.into(),
            }),
            TaggedOperator::Reduce(r) => air::Expression::Reduce(air::Reduce {
                input: r.input.into(),
                init_value: r.initial_value.into(),
                inside: r.inside.into(),
            }),
            TaggedOperator::Cond(c) => air::Expression::MQLSemanticOperator(MQLSemanticOperator {
                op: MQLOperator::Cond,
                args: vec![(*c.r#if).into(), (*c.then).into(), (*c.r#else).into()],
            }),
            x => panic!(
                "tagged operator {:?}, should not be generated by mongosql",
                x
            ),
        }
    }
}

fn str_to_air_sqcop(
    op: &str,
) -> Option<(air::SubqueryComparisonOp, air::SubqueryComparisonOpType)> {
    let op_type = if op.starts_with("sql") {
        air::SubqueryComparisonOpType::Sql
    } else {
        air::SubqueryComparisonOpType::Mql
    };
    let op = op.trim_start_matches("sql");
    match op {
        "lt" | "Lt" => Some((air::SubqueryComparisonOp::Lt, op_type)),
        "lte" | "Lte" => Some((air::SubqueryComparisonOp::Lte, op_type)),
        // might as well support ne and neq both
        "ne" | "neq" | "Ne" | "Neq" => Some((air::SubqueryComparisonOp::Neq, op_type)),
        "eq" | "Eq" => Some((air::SubqueryComparisonOp::Eq, op_type)),
        "gt" | "Gt" => Some((air::SubqueryComparisonOp::Gt, op_type)),
        "gte" | "Gte" => Some((air::SubqueryComparisonOp::Gte, op_type)),
        _ => None,
    }
}

fn str_to_air_sqcmod(m: &str) -> Option<air::SubqueryModifier> {
    match m {
        "all" => Some(air::SubqueryModifier::All),
        "any" => Some(air::SubqueryModifier::Any),
        _ => None,
    }
}

fn str_to_air_type(t: String) -> air::Type {
    match t.as_str() {
        "array" => air::Type::Array,
        "binData" => air::Type::BinData,
        "bool" => air::Type::Boolean,
        "date" => air::Type::Datetime,
        "dbPointer" => air::Type::DbPointer,
        "decimal" => air::Type::Decimal128,
        "object" => air::Type::Document,
        "double" => air::Type::Double,
        "int" => air::Type::Int32,
        "long" => air::Type::Int64,
        "javascript" => air::Type::Javascript,
        "javascriptWithScope" => air::Type::JavascriptWithScope,
        "maxKey" => air::Type::MaxKey,
        "minKey" => air::Type::MinKey,
        "null" => air::Type::Null,
        "objectId" => air::Type::ObjectId,
        "regex" => air::Type::RegularExpression,
        "string" => air::Type::String,
        "symbol" => air::Type::Symbol,
        "timestamp" => air::Type::Timestamp,
        "undefined" => air::Type::Undefined,
        _ => panic!("invalid $convert or $is target type '{t}'"),
    }
}

impl From<UntaggedOperator> for air::Expression {
    fn from(ast_op: UntaggedOperator) -> Self {
        let args: Vec<air::Expression> =
            ast_op.args.into_iter().map(air::Expression::from).collect();

        // Special cases:
        //   - $literal becomes a Literal or Document
        //   - $is/$sqlIs become an Is
        //   - $nullIf and $coalesce are SQL operators but don't start with $sql
        use agg_ast::definitions::UntaggedOperatorName;
        match ast_op.op {
            UntaggedOperatorName::Literal => {
                let arg = args.first().unwrap();
                match arg {
                    air::Expression::Literal(_) => return arg.clone(),
                    air::Expression::Document(_) => return arg.clone(),
                    _ => panic!("invalid $literal"),
                }
            }
            UntaggedOperatorName::Is | UntaggedOperatorName::SQLIs => {
                let expr = Box::new(args.first().unwrap().clone());

                let arg2 = match args.get(1).unwrap() {
                    air::Expression::Literal(air::LiteralValue::String(s)) => s,
                    _ => panic!("invalid second arg to $is/$sqlUntaggedOperatorName::Is"),
                };
                let target_type = to_type_or_missing(arg2.clone());

                return air::Expression::Is(air::Is { expr, target_type });
            }
            UntaggedOperatorName::NullIf => {
                return air::Expression::SQLSemanticOperator(air::SQLSemanticOperator {
                    op: air::SQLOperator::NullIf,
                    args,
                })
            }
            UntaggedOperatorName::Coalesce => {
                return air::Expression::SQLSemanticOperator(air::SQLSemanticOperator {
                    op: air::SQLOperator::Coalesce,
                    args,
                })
            }
            UntaggedOperatorName::NumberDouble => {
                if let air::Expression::Literal(air::LiteralValue::String(s)) = args[0].clone() {
                    if s == "Infinity" {
                        return air::Expression::Literal(air::LiteralValue::Double(f64::INFINITY));
                    } else if s == "-Infinity" {
                        return air::Expression::Literal(air::LiteralValue::Double(
                            f64::NEG_INFINITY,
                        ));
                    } else if s == "NaN" {
                        return air::Expression::Literal(air::LiteralValue::Double(f64::NAN));
                    }
                }
            }
            _ => (),
        }

        macro_rules! sql_op {
            ($op:expr) => {
                air::Expression::SQLSemanticOperator(air::SQLSemanticOperator { op: $op, args })
            };
        }
        macro_rules! mql_op {
            ($op:expr) => {
                air::Expression::MQLSemanticOperator(air::MQLSemanticOperator { op: $op, args })
            };
        }

        match ast_op.op {
            UntaggedOperatorName::SQLPos => sql_op!(air::SQLOperator::Pos),
            UntaggedOperatorName::SQLNeg => sql_op!(air::SQLOperator::Neg),
            UntaggedOperatorName::SQLLt => sql_op!(air::SQLOperator::Lt),
            UntaggedOperatorName::SQLLte => sql_op!(air::SQLOperator::Lte),
            UntaggedOperatorName::SQLNe => sql_op!(air::SQLOperator::Ne),
            UntaggedOperatorName::SQLEq => sql_op!(air::SQLOperator::Eq),
            UntaggedOperatorName::SQLGt => sql_op!(air::SQLOperator::Gt),
            UntaggedOperatorName::SQLGte => sql_op!(air::SQLOperator::Gte),
            UntaggedOperatorName::SQLBetween => sql_op!(air::SQLOperator::Between),
            UntaggedOperatorName::SQLNot => sql_op!(air::SQLOperator::Not),
            UntaggedOperatorName::SQLAnd => sql_op!(air::SQLOperator::And),
            UntaggedOperatorName::SQLOr => sql_op!(air::SQLOperator::Or),
            UntaggedOperatorName::SQLSlice => sql_op!(air::SQLOperator::Slice),
            UntaggedOperatorName::SQLSize => sql_op!(air::SQLOperator::Size),
            UntaggedOperatorName::SQLIndexOfCP => sql_op!(air::SQLOperator::IndexOfCP),
            UntaggedOperatorName::SQLStrLenCP => sql_op!(air::SQLOperator::StrLenCP),
            UntaggedOperatorName::SQLStrLenBytes => sql_op!(air::SQLOperator::StrLenBytes),
            UntaggedOperatorName::SQLBitLength => sql_op!(air::SQLOperator::BitLength),
            UntaggedOperatorName::SQLCos => sql_op!(air::SQLOperator::Cos),
            UntaggedOperatorName::SQLLog => sql_op!(air::SQLOperator::Log),
            UntaggedOperatorName::SQLMod => sql_op!(air::SQLOperator::Mod),
            UntaggedOperatorName::SQLRound => sql_op!(air::SQLOperator::Round),
            UntaggedOperatorName::SQLSin => sql_op!(air::SQLOperator::Sin),
            UntaggedOperatorName::SQLSqrt => sql_op!(air::SQLOperator::Sqrt),
            UntaggedOperatorName::SQLTan => sql_op!(air::SQLOperator::Tan),
            UntaggedOperatorName::SQLSubstrCP => sql_op!(air::SQLOperator::SubstrCP),
            UntaggedOperatorName::SQLToUpper => sql_op!(air::SQLOperator::ToUpper),
            UntaggedOperatorName::SQLToLower => sql_op!(air::SQLOperator::ToLower),
            UntaggedOperatorName::SQLSplit => sql_op!(air::SQLOperator::Split),
            UntaggedOperatorName::Concat => mql_op!(air::MQLOperator::Concat),
            UntaggedOperatorName::Cond => mql_op!(air::MQLOperator::Cond),
            UntaggedOperatorName::IfNull => mql_op!(air::MQLOperator::IfNull),
            UntaggedOperatorName::Add => mql_op!(air::MQLOperator::Add),
            UntaggedOperatorName::Subtract => mql_op!(air::MQLOperator::Subtract),
            UntaggedOperatorName::Multiply => mql_op!(air::MQLOperator::Multiply),
            UntaggedOperatorName::Divide => mql_op!(air::MQLOperator::Divide),
            UntaggedOperatorName::Lt => mql_op!(air::MQLOperator::Lt),
            UntaggedOperatorName::Lte => mql_op!(air::MQLOperator::Lte),
            UntaggedOperatorName::Ne => mql_op!(air::MQLOperator::Ne),
            UntaggedOperatorName::Eq => mql_op!(air::MQLOperator::Eq),
            UntaggedOperatorName::Gt => mql_op!(air::MQLOperator::Gt),
            UntaggedOperatorName::Gte => mql_op!(air::MQLOperator::Gte),
            UntaggedOperatorName::MQLBetween => mql_op!(air::MQLOperator::Between),
            UntaggedOperatorName::Not => mql_op!(air::MQLOperator::Not),
            UntaggedOperatorName::And => mql_op!(air::MQLOperator::And),
            UntaggedOperatorName::Or => mql_op!(air::MQLOperator::Or),
            UntaggedOperatorName::Slice => mql_op!(air::MQLOperator::Slice),
            UntaggedOperatorName::Size => mql_op!(air::MQLOperator::Size),
            UntaggedOperatorName::ArrayElemAt => mql_op!(air::MQLOperator::ElemAt),
            UntaggedOperatorName::In => mql_op!(air::MQLOperator::In),
            UntaggedOperatorName::First => mql_op!(air::MQLOperator::First),
            UntaggedOperatorName::Last => mql_op!(air::MQLOperator::Last),
            UntaggedOperatorName::AllElementsTrue => mql_op!(air::MQLOperator::AllElementsTrue),
            UntaggedOperatorName::IndexOfCP => mql_op!(air::MQLOperator::IndexOfCP),
            UntaggedOperatorName::IndexOfBytes => mql_op!(air::MQLOperator::IndexOfBytes),
            UntaggedOperatorName::StrLenCP => mql_op!(air::MQLOperator::StrLenCP),
            UntaggedOperatorName::StrLenBytes => mql_op!(air::MQLOperator::StrLenBytes),
            UntaggedOperatorName::Abs => mql_op!(air::MQLOperator::Abs),
            UntaggedOperatorName::Ceil => mql_op!(air::MQLOperator::Ceil),
            UntaggedOperatorName::Cos => mql_op!(air::MQLOperator::Cos),
            UntaggedOperatorName::DegreesToRadians => mql_op!(air::MQLOperator::DegreesToRadians),
            UntaggedOperatorName::Floor => mql_op!(air::MQLOperator::Floor),
            UntaggedOperatorName::Log => mql_op!(air::MQLOperator::Log),
            UntaggedOperatorName::Mod => mql_op!(air::MQLOperator::Mod),
            UntaggedOperatorName::Pow => mql_op!(air::MQLOperator::Pow),
            UntaggedOperatorName::RadiansToDegrees => mql_op!(air::MQLOperator::RadiansToDegrees),
            UntaggedOperatorName::Round => mql_op!(air::MQLOperator::Round),
            UntaggedOperatorName::Sin => mql_op!(air::MQLOperator::Sin),
            UntaggedOperatorName::Tan => mql_op!(air::MQLOperator::Tan),
            UntaggedOperatorName::Sqrt => mql_op!(air::MQLOperator::Sqrt),
            UntaggedOperatorName::Avg => mql_op!(air::MQLOperator::Avg),
            UntaggedOperatorName::Max => mql_op!(air::MQLOperator::Max),
            UntaggedOperatorName::Min => mql_op!(air::MQLOperator::Min),
            UntaggedOperatorName::Sum => mql_op!(air::MQLOperator::Sum),
            UntaggedOperatorName::StdDevPop => mql_op!(air::MQLOperator::StddevPop),
            UntaggedOperatorName::StdDevSamp => mql_op!(air::MQLOperator::StddevSamp),
            UntaggedOperatorName::SubstrCP => mql_op!(air::MQLOperator::SubstrCP),
            UntaggedOperatorName::SubstrBytes => mql_op!(air::MQLOperator::SubstrBytes),
            UntaggedOperatorName::ToUpper => mql_op!(air::MQLOperator::ToUpper),
            UntaggedOperatorName::ToLower => mql_op!(air::MQLOperator::ToLower),
            UntaggedOperatorName::Split => mql_op!(air::MQLOperator::Split),
            UntaggedOperatorName::MergeObjects => mql_op!(air::MQLOperator::MergeObjects),
            UntaggedOperatorName::ObjectToArray => mql_op!(air::MQLOperator::ObjectToArray),
            UntaggedOperatorName::Type => mql_op!(air::MQLOperator::Type),
            UntaggedOperatorName::IsArray => mql_op!(air::MQLOperator::IsArray),
            UntaggedOperatorName::IsNumber => mql_op!(air::MQLOperator::IsNumber),
            _ => panic!("unused agg-ast operator: {:?}", ast_op.op),
        }
    }
}

fn to_type_or_missing(s: String) -> air::TypeOrMissing {
    match s.as_str() {
        "missing" => air::TypeOrMissing::Missing,
        "number" => air::TypeOrMissing::Number,
        _ => air::TypeOrMissing::Type(str_to_air_type(s)),
    }
}
